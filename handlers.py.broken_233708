from alert_queue import alert_queue
#!/usr/bin/env python3
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from config import logger, ADMIN_IDS, EXCHANGES, TIMEFRAMES, USDT_ADDRESS
from database import db
from alerts_db import alerts_db
from exchange_api import exchange_api
from format_price import format_price
from ai_trader import ai_trader
import json

import json

# Load translations
try:
    with open('translations.json', 'r', encoding='utf-8') as f:
        TRANSLATIONS = json.load(f)
except:
    TRANSLATIONS = {}

def get_text(key, lang='pl', **kwargs):
    """Get translated text"""
    text = TRANSLATIONS.get(lang, {}).get(key, key)
    if kwargs:
        try:
            text = text.format(**kwargs)
        except:
            pass
    return text

# ==========================================
# HELPER FUNCTIONS
# ==========================================
def format_subscription_status(subscription_end, is_blocked=False):
    """Format subscription status"""
    if is_blocked:
        return 'ğŸš« Zablokowany'
    if not subscription_end:
        return 'âš ï¸ Brak subskrypcji (0 dni)'
    try:
        expires_date = datetime.fromisoformat(subscription_end)
        days_left = (expires_date - datetime.now()).days
        if days_left <= 0:
            return 'âŒ WygasÅ‚a (0 dni)'
        elif days_left <= 7:
            return f'âš ï¸ Premium ({days_left} dni)'
        else:
            return f'âœ… Premium ({days_left} dni)'
    except:
        return 'âš ï¸ Brak subskrypcji'
def back_button(callback_data='back_main'):
    """Universal back button"""
    return InlineKeyboardMarkup([[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data=callback_data)]])
# ==========================================
# START COMMAND
# ==========================================
def create_quick_interval_buttons(symbol, current_timeframe, callback_prefix='analyze'):
    safe_symbol = symbol.replace('/', '_')
    rows = [
        ['1m', '5m', '15m', '30m', '1h'],
        ['4h', '8h', '1d', '1w', '1M']
    ]
    keyboard = []
    for row_tfs in rows:
        row = []
        for tf in row_tfs:
            if tf == current_timeframe:
                row.append(InlineKeyboardButton(f"â€¢ {tf} â€¢", callback_data="noop"))
            else:
                row.append(InlineKeyboardButton(tf, callback_data=f"{callback_prefix}_{safe_symbol}_mexc_{tf}"))
        keyboard.append(row)
    return InlineKeyboardMarkup(keyboard)

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command - main menu"""
    user = update.effective_user
    user_id = user.id
    # Get or create user
    user_data = db.get_user(user_id)
    lang = user_data.get('language', 'pl')  # Get user language
    # Format status
    sub_status = format_subscription_status(user_data.get('subscription_end'), user_data.get('is_blocked', False))
    is_admin = user_id in ADMIN_IDS
    welcome = f"""ğŸ‘‹ BOTrader Bot
Status: {sub_status}
ğŸ†” ID: {user_id}
âœ¨ Wpisz nazwÄ™ pary (np. BTC) aby wyszukaÄ‡
ğŸ“Š Lub uÅ¼yj menu poniÅ¼ej"""
    keyboard = [
        [InlineKeyboardButton("ğŸ” Wyszukaj parÄ™", callback_data="search_pair")],
        [InlineKeyboardButton("ğŸ“Š Skaner ekstremÃ³w", callback_data="scan_extremes")],
        [InlineKeyboardButton("ğŸ¯ SygnaÅ‚y AI", callback_data='ai_signals')],
        [InlineKeyboardButton("ğŸ”” Alerty", callback_data="alerts_menu")],
        [InlineKeyboardButton("ğŸ’¬ Czat z adminem", callback_data='admin_chat')],
        [InlineKeyboardButton("âš™ï¸ Ustawienia", callback_data="settings")],
        [InlineKeyboardButton("â„¹ï¸ WyjaÅ›nienia", callback_data='explanations_menu')],
        [InlineKeyboardButton("ğŸ’ Subskrypcja", callback_data='subscription')],
        [InlineKeyboardButton("â­ OceÅ„ bota", callback_data='rate_bot')]
    ]
    if is_admin:
        keyboard.append([InlineKeyboardButton("ğŸ‘‘ Admin Panel", callback_data='admin_panel')])
    await update.message.reply_text(welcome, reply_markup=InlineKeyboardMarkup(keyboard))
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle all button callbacks"""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user = db.get_user(user_id)
    if not user:

    # Chart display (PRIORITY - before other checks)
    if query.data.startswith('chart_'):
        signal_id = query.data.replace('chart_', '')
        await show_signal_chart(query, signal_id)
        return
    
        await query.edit_message_text("âŒ UÅ¼ytkownik nie znaleziony. WyÅ›lij /start")
        return

    # Portfolio callbacks
    if query.data.startswith('portfolio_'):
    el        elif query.data == 'portfolio_main':
            await portfolio_main(query, user_id, user)

        elif query.data == 'portfolio_dashboard':
            await portfolio_dashboard(query, user_id, user)
        elif query.data == 'portfolio_open':
            await portfolio_open(query, user_id, user)
        elif query.data == 'portfolio_add_start':
            await portfolio_add_start(query, user_id, user)
        elif query.data.startswith('portfolio_view_'):
            pos_id = query.data.replace('portfolio_view_', '')
            await portfolio_view(query, user_id, user, pos_id)
        elif query.data.startswith('portfolio_close_confirm_'):
            pos_id = query.data.replace('portfolio_close_confirm_', '')
            await portfolio_close_confirm(query, user_id, user, pos_id)
        elif query.data.startswith('portfolio_close_yes_'):
            pos_id = query.data.replace('portfolio_close_yes_', '')
            await portfolio_close_execute(query, user_id, user, pos_id)
        elif query.data.startswith('portfolio_type_'):
            pos_type = query.data.replace('portfolio_type_', '')
            await handle_portfolio_type(query, user_id, user, pos_type)
        elif query.data.startswith('portfolio_lev_'):
            leverage = int(query.data.replace('portfolio_lev_', ''))
            await handle_portfolio_leverage(query, user_id, user, leverage)
        elif query.data == 'portfolio_skip_targets':
            await finish_portfolio_add(query, user_id, user, None, None, None, None)
        return
    
    data = query.data
    print(f"DEBUG: Callback data: {data}")
    user['last_active'] = datetime.now().isoformat()
    db.update_user(user_id, user)
    if data == 'back_main':
        await start_command_from_callback(query, user_id, user)
        return
    elif data == 'search_pair':
        await search_pair_menu(query, user_id, user)
        return
    elif data == 'show_cached_scan':
        await show_cached_scan(query, user_id, user)
        return
    elif data == 'ai_signals':
        await ai_signals_menu_advanced(query, user_id, user)
        return
    elif data.startswith('ai_scan_'):
        timeframe = data.replace('ai_scan_', '')
        await ai_scan_select_size(query, user_id, user, timeframe)
        return
    elif data.startswith('ai_run_'):
        parts = data.replace('ai_run_', '').split('_')
        timeframe = parts[0]
        scan_size = parts[1] if len(parts) > 1 else 'top10'
        await ai_scan_speed_choice(query, user_id, user, timeframe, scan_size)
        return

    elif data.startswith('ai_fast_'):
        parts = data.replace('ai_fast_', '').split('_')
        timeframe = parts[0]
        scan_size = parts[1] if len(parts) > 1 else 'top10'
        user['scan_mode'] = 'fast'
        await ai_scan_execute(query, user_id, user, timeframe, scan_size)
        return
    
    elif data.startswith('ai_full_'):
        parts = data.replace('ai_full_', '').split('_')
        timeframe = parts[0]
        scan_size = parts[1] if len(parts) > 1 else 'top10'
        user['scan_mode'] = 'full'
        await ai_scan_execute(query, user_id, user, timeframe, scan_size)
        return
    elif data == 'rate_bot':
        await rate_bot_menu(query, user_id, user)
        return
    elif data.startswith('rate_'):
        stars = data.replace('rate_', '')
        await query.answer(f"âœ… DziÄ™kujemy za {'â­' * int(stars)}!")
        await start_command_from_callback(query, user_id, user)
        return
    elif data == 'explanations_menu':
        await explanations_menu(query, user_id, user)
        return
    elif data == 'scan_extremes':
        await scan_extremes_menu(query, user_id, user)
        return
    elif data.startswith('scan_select_'):
        # Menu wyboru rozmiaru
        scan_type = data.replace('scan_select_', '')
        await scan_size_menu(query, user_id, user, scan_type)
        return
    elif data.startswith('scan_') and '_' in data:
        # scan_TYPE_SIZE (np. scan_gainers_50)
        parts = data.replace('scan_', '').rsplit('_', 1)
        if len(parts) == 2:
            scan_type = f'scan_{parts[0]}'
            size_str = parts[1]
            size = int(size_str) if size_str.isdigit() else 9999  # 'all' = 9999
            await handle_scan(query, user_id, user, scan_type, size)
        return
    elif data.startswith('scan_'):
        # Stary format (fallback)
        await handle_scan(query, user_id, user, data, 50)
        return

    elif data == 'explanations_menu':
        await explanations_menu(query, user_id, user)
        return
    
    elif data == 'explain_signals':
        await explain_signals(query, user_id, user)
        return
    
    elif data == 'explain_indicators':
        await explain_indicators(query, user_id, user)
        return
    
    elif data == 'explain_alerts':
        await explain_alerts(query, user_id, user)
        return
    
    elif data == 'explain_settings':
        await explain_settings(query, user_id, user)
        return
    
    elif data == 'settings':
        await settings_menu(query, user_id, user)
        return
    elif data == 'back_main':
        await start_command_from_callback(query, user_id, user)
        return
    elif data.startswith('alert_detail_'):
        index = int(data.replace('alert_detail_', ''))
        await show_alert_detail(query, user_id, user, index)
        return
    elif data == 'alerts_menu':
        await alerts_menu(query, user_id, user)
        return
    elif data == 'alerts_settings':
        await alerts_settings_menu(query, user_id, user)
        return

    elif data == 'alerts_sudden_settings':
        await alerts_sudden_settings(query, user_id, user)
        return
    
    elif data == 'toggle_sudden_alert':
        await toggle_sudden_alert(query, user_id, user)
        return
    
    elif data == 'set_sudden_threshold_menu':
        await set_sudden_threshold_menu(query, user_id, user)
        return

    elif data.startswith('set_sudden_thresh_'):
        threshold = int(data.replace('set_sudden_thresh_', ''))
        await set_sudden_threshold(query, user_id, user, threshold)
        return
    
    
    elif data == 'set_sudden_timeframe_menu':
        await set_sudden_timeframe_menu(query, user_id, user)
        return
    
    elif data.startswith('alerts_page_'):
        page = int(data.replace('alerts_page_', ''))
        await alerts_history_menu(query, user_id, user, page=page)
        return
    elif data == 'alerts_history':
        await alerts_history_menu(query, user_id, user)
        return
    elif data.startswith('toggle_alert_'):
        await query.answer()
        alert_type = data.replace('toggle_alert_', '')
        await toggle_alert(query, user_id, user, alert_type)
        return
    elif data.startswith('set_scan_range_'):
        range_val = int(data.replace('set_scan_range_', ''))
        await set_scan_range(query, user_id, user, range_val)
        return
    elif data.startswith('set_scan_freq_'):
        freq = data.replace('set_scan_freq_', '')
        await set_scan_frequency(query, user_id, user, freq)
        return
    elif data == 'set_scan_range':
        await set_scan_range(query, user_id, user)
        return
    elif data == 'set_scan_frequency':
        await set_scan_frequency(query, user_id, user)
        return
    elif data == 'set_alert_timeframe':
        await set_alert_timeframe(query, user_id, user)
        return
    elif data == 'set_sudden_timeframe':
        await set_sudden_timeframe_menu(query, user_id, user)
        return
    elif data.startswith('set_sudden_tf_'):
        tf = data.replace('set_sudden_tf_', '')
        await set_sudden_timeframe(query, user_id, user, tf)
        return
    elif data == 'set_sudden_threshold':
        await set_sudden_threshold_menu(query, user_id, user)
        return
    elif data.startswith('set_sudden_th_'):
        threshold = int(data.replace('set_sudden_th_', ''))
        await set_sudden_threshold(query, user_id, user, threshold)
        return
    elif data.startswith('analyze_'):
        await query.answer()
        # Format: analyze_BTC_USDT_USDT_1h
        parts = data.replace('analyze_', '').rsplit('_', 1)
        symbol_encoded = parts[0]
        timeframe = parts[1] if len(parts) > 1 else '1h'
        # Decode symbol
        symbol = symbol_encoded.replace('_USDT_USDT', '/USDT:USDT').replace('_', '/')
        await analyze_from_alert(query, user_id, user, symbol, timeframe)
        return
    elif data.startswith('set_alert_tf_'):
        tf = data.replace('set_alert_tf_', '')
        await set_alert_timeframe(query, user_id, user, tf)
        return
    elif data == 'back_main':
        await start_command_from_callback(query, user_id, user)
        return
    elif data == 'alerts_menu':
        await alerts_menu(query, user_id, user)
        return
    elif data == 'alerts_settings':
        await alerts_settings_menu(query, user_id, user)
        return
    elif data.startswith('alerts_page_'):
        page = int(data.replace('alerts_page_', ''))
        await alerts_history_menu(query, user_id, user, page=page)
        return
    elif data == 'alerts_history':
        await alerts_history_menu(query, user_id, user)
        return
    elif data.startswith('toggle_alert_'):
        await query.answer()
        alert_type = data.replace('toggle_alert_', '')
        await toggle_alert(query, user_id, user, alert_type)
        return
    elif data.startswith('set_scan_range_'):
        range_val = int(data.replace('set_scan_range_', ''))
        await set_scan_range(query, user_id, user, range_val)
        return
    elif data.startswith('set_scan_freq_'):
        freq = data.replace('set_scan_freq_', '')
        await set_scan_frequency(query, user_id, user, freq)
        return
    elif data == 'change_exchange':
        await change_exchange_menu(query, user_id, user)
        return
    elif data.startswith('set_exchange_'):
        exchange = data.replace('set_exchange_', '')
        user['selected_exchange'] = exchange
        db.update_user(user_id, user)
        await query.answer(f"âœ… Zmieniono na {EXCHANGES[exchange]['name']}")
        await settings_menu(query, user_id, user)
        return
    elif data == 'change_interval':
        await change_interval_menu(query, user_id, user)
        return
    elif data.startswith('set_interval_'):
        interval = data.replace('set_interval_', '')
        user['interval'] = interval
        db.update_user(user_id, user)
        await query.answer(f"âœ… Zmieniono na {TIMEFRAMES[interval]['label']}")
        await settings_menu(query, user_id, user)
        return
    elif data == 'language_menu':
        await language_menu(query, user_id, user)
        return
    elif data.startswith('set_lang_'):
        lang = data.replace('set_lang_', '')
        user['language'] = lang
        db.update_user(user_id, user)
        from languages import LANGUAGES
        await query.answer(f"âœ… Language changed to {LANGUAGES[lang]['name']}")
        await settings_menu(query, user_id, user)
        return
    elif data == 'subscription':
        await subscription_menu(query, user_id, user)
        return
    elif data == 'payment_info':
        await payment_info_menu(query, user_id, user)
        return
    elif data == 'back_main':
        await start_command_from_callback(query, user_id, user)
        return
    elif data == 'alerts_menu':
        await alerts_menu(query, user_id, user)
        return
    elif data == 'admin_chat':
        await admin_chat_menu(query, user_id, user)
        return
    elif data == 'admin_features_menu':
        await admin_features_menu(query, user_id, user)
        return
    
    elif data == 'admin_toggle_subscription':
        await admin_toggle_feature(query, user_id, 'subscription_enabled')
        return
    
    elif data == 'admin_toggle_referral':
        await admin_toggle_feature(query, user_id, 'referral_enabled')
        return
    
    elif data == 'admin_signals_stats':
        await admin_signals_stats(query, user_id, user)
        return
    
    elif data == 'admin_export_signals':
        await admin_export_signals(query, user_id, user)
        return
    
    elif data == "admin_ai_settings":
        await admin_ai_settings(query, user_id, user)
        return
    elif data.startswith("aiw_"):
        if user_id not in ADMIN_IDS:
            await query.answer("âŒ")
            return
        w = int(data.replace("aiw_", ""))
        import json
        try:
            with open("user_data.json") as f: d = json.load(f)
        except: d = {}
        if "config" not in d: d["config"] = {}
        d["config"]["max_ai_workers"] = w
        with open("user_data.json", "w") as f: json.dump(d, f, indent=2)
        await query.answer(f"âœ… {w}")
        await admin_ai_settings(query, user_id, user)
        return
    elif data == 'admin_ai_settings':
        await admin_ai_settings(query, user_id, user)
        return
    elif data.startswith('aiw_'):
        if user_id not in ADMIN_IDS:
            await query.answer("âŒ")
            return
        w = int(data.replace('aiw_', ''))
        import json
        try:
            with open('user_data.json') as f: d = json.load(f)
        except: d = {}
        if 'config' not in d: d['config'] = {}
        d['config']['max_ai_workers'] = w
        with open('user_data.json', 'w') as f: json.dump(d, f, indent=2)
        await query.answer(f"âœ… {w}")
        await admin_ai_settings(query, user_id, user)
        return
    elif data == 'admin_panel':
        if user_id not in ADMIN_IDS:
            await query.answer("âŒ Brak dostÄ™pu")
            return
        await admin_panel(query, user_id, user)
        return

    elif data == 'admin_users_list':
        await admin_users_list(query, user_id, user, page=0)
        return
    
    elif data.startswith('admin_users_page_'):
        page = int(data.replace('admin_users_page_', ''))
        await admin_users_list(query, user_id, user, page=page)
        return
    
    elif data.startswith('admin_user_'):
        target_uid = data.replace('admin_user_', '')
        await admin_user_manage(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_msg_write_'):
        target_uid = data.replace('admin_msg_write_', '')
        await admin_msg_write(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_chat_'):
        target_uid = data.replace('admin_chat_', '')
        await admin_chat_view(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_add_days_'):
        target_uid = data.replace('admin_add_days_', '')
        await admin_add_days_menu(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_remove_days_'):
        target_uid = data.replace('admin_remove_days_', '')
        await admin_remove_days_menu(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_give_days_'):
        parts = data.replace('admin_give_days_', '').split('_')
        target_uid = parts[0]
        days = int(parts[1])
        await admin_give_days(query, user_id, target_uid, days)
        return
    
    elif data.startswith('admin_take_days_'):
        parts = data.replace('admin_take_days_', '').split('_')
        target_uid = parts[0]
        days = int(parts[1])
        await admin_take_days(query, user_id, target_uid, days)
        return
    
    elif data.startswith('admin_toggle_premium_'):
        target_uid = data.replace('admin_toggle_premium_', '')
        await admin_toggle_premium(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_delete_confirm_'):
        target_uid = data.replace('admin_delete_confirm_', '')
        await admin_delete_user_confirm(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_delete_yes_'):
        target_uid = data.replace('admin_delete_yes_', '')
        await admin_delete_user(query, user_id, target_uid)
        return
    
    elif data.startswith('admin_clear_chat_'):
        target_uid = data.replace('admin_clear_chat_', '')
        await admin_clear_chat(query, user_id, target_uid)
        return
    
    elif data == 'admin_broadcast_write':
        await admin_broadcast_write(query, user_id)
        return
    
    elif data == 'admin_broadcast_send':
        await admin_broadcast_send(query, user_id, context)
        return
    
    elif data == 'admin_broadcast':
        await admin_broadcast_menu(query, user_id)
        return
    
    elif data == 'admin_stats_detailed':
        await admin_stats_detailed(query, user_id)
        return
    elif data == 'admin_stats':
        await admin_stats_menu(query, user_id, user)
        return
    elif data == 'admin_add_days':
        await admin_add_days_menu(query, user_id, user)
        return
    elif data.startswith('admin_user_'):
        target_uid = int(data.replace('admin_user_', ''))
        await admin_user_manage(query, user_id, target_uid)
        return
    elif data.startswith('admin_give_'):
        parts = data.replace('admin_give_', '').split('_')
        target_uid = int(parts[0])
        days = int(parts[1])
        await admin_give_days(query, user_id, target_uid, days)
        return
    elif data.startswith('admin_promo_all_'):
        days = int(data.replace('admin_promo_all_', ''))
        await admin_promo_all(query, user_id, days)
        return
    elif data == 'ignore':
        await query.answer()
        return
    elif data.startswith('analyze_'):
        await query.answer()
        # analyze_SYMBOL_TIMEFRAME lub analyze_SYMBOL (default 15m)
        parts = data.replace('analyze_', '').split('_')
        symbol = parts[0]
        timeframe = parts[1] if len(parts) > 1 else user.get('interval', '15m')
        exchange = user.get('selected_exchange', 'mexc').lower()
        # Dodaj /USDT jeÅ›li brak
        if '/USDT' not in symbol:
            symbol = symbol + '/USDT'
        await show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, 'manual')
        return
    elif data.startswith('ai_page_'):
        # Zmiana strony AI Signals
        page = int(data.replace('ai_page_', ''))
        user['ai_current_page'] = page
        db.update_user(user_id, user)
        
        # Pobierz cached results
        results = user.get('cached_scan_results', [])
        if not results:
            await query.edit_message_text("âŒ Brak cached scan", reply_markup=back_button('ai_signals'))
            return
        
        timeframe = user.get('last_timeframe', '1h')
        exchange = user.get('selected_exchange', 'mexc')
        
        # Pagination
        per_page = 10
        total_pages = (len(results) + per_page - 1) // per_page
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        page_results = results[start_idx:end_idx]
        
        # Build message
        text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
â± Timeframe: {timeframe}
ğŸ“Š Znaleziono: {len(results)} sygnaÅ‚Ã³w (Strona {page}/{total_pages})
ğŸ’¡ Kliknij parÄ™ aby zobaczyÄ‡ peÅ‚nÄ… analizÄ™ AI!
"""
        
        keyboard = []
        for r in page_results:
            emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´"
            symbol_clean = r['symbol'].replace('/USDT:USDT', '')
            label = f"{emoji} {symbol_clean} | {r['signal']} {r['confidence']}%"
            keyboard.append([InlineKeyboardButton(label, callback_data=f'ai_sig_{symbol_clean}_{timeframe}')])
        
        # Navigation
        nav_row = []
        if page > 1:
            nav_row.append(InlineKeyboardButton('â—€ï¸ Poprzednia', callback_data=f'ai_page_{page-1}'))
        if page < total_pages:
            nav_row.append(InlineKeyboardButton('NastÄ™pna â–¶ï¸', callback_data=f'ai_page_{page+1}'))
        if nav_row:
            keyboard.append(nav_row)
        
        keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')])
        
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    elif data.startswith('ai_sig_'):
        # ai_sig_SYMBOL_TIMEFRAME - z kontekstem AI signals
        parts = data.replace('ai_sig_', '').split('_')
        symbol = parts[0]
        timeframe = parts[1] if len(parts) > 1 else user.get('interval', '15m')
        exchange = user.get('selected_exchange', 'mexc').lower()
        # Dodaj /USDT
        if '/USDT' not in symbol:
            symbol = symbol + '/USDT'
        await show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, 'ai_signal')
        return
    elif data.startswith('details_'):
        # Pokazuje wiÄ™cej szczegÃ³Å‚Ã³w
        parts = data.replace('details_', '').split('_')
        symbol = parts[0]
        timeframe = parts[1] if len(parts) > 1 else user.get('interval', '15m')
        await query.answer("ğŸ”§ SzczegÃ³Å‚owa analiza - w przygotowaniu!")
        return
# ==========================================
# SCAN EXTREMES
# ==========================================
async def scan_extremes_menu(query, user_id, user):
    """Scan extremes menu"""
    text = """ğŸ“Š SKANER EKSTREMÃ“W
Wybierz typ skanowania:
ğŸš€ Wzrosty - najwiÄ™ksze wzrosty ceny
ğŸ“‰ Spadki - najwiÄ™ksze spadki ceny
ğŸ”¥ RSI < 30 - oversold
ğŸ’ RSI > 70 - overbought
ğŸ“ˆ Volume - najwiÄ™kszy wolumen"""
    keyboard = [
        [InlineKeyboardButton("ğŸš€ Wzrosty", callback_data='scan_select_gainers')],
        [InlineKeyboardButton("ğŸ“‰ Spadki", callback_data='scan_select_losers')],
        [InlineKeyboardButton("ğŸ”¥ RSI Oversold", callback_data='scan_select_rsi_oversold')],
        [InlineKeyboardButton("ğŸ’ RSI Overbought", callback_data='scan_select_rsi_overbought')],
        [InlineKeyboardButton("ğŸ“ˆ Volume TOP", callback_data='scan_select_volume')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def scan_size_menu(query, user_id, user, scan_type):
    """Menu wyboru rozmiaru skanowania"""
    scan_names = {
        'gainers': 'ğŸš€ WZROSTY',
        'losers': 'ğŸ“‰ SPADKI',
        'rsi_oversold': 'ğŸ”¥ RSI OVERSOLD',
        'rsi_overbought': 'ğŸ’ RSI OVERBOUGHT',
        'volume': 'ğŸ“ˆ VOLUME TOP'
    }
    text = f"""ğŸ“Š {scan_names.get(scan_type, 'SKANER')}
Wybierz zakres skanowania:
â€¢ TOP 50 - szybkie (~10 sek)
â€¢ TOP 100 - Å›rednie (~20 sek)
â€¢ TOP 200 - wolne (~40 sek)
â€¢ WSZYSTKIE - najdokÅ‚adniejsze (~2 min)
Im wiÄ™cej par, tym lepsze okazje! ğŸ’"""
    keyboard = [
        [InlineKeyboardButton('âš¡ TOP 50 (~10s)', callback_data=f'scan_{scan_type}_50')],
        [InlineKeyboardButton('ğŸ“Š TOP 100 (~20s)', callback_data=f'scan_{scan_type}_100')],
        [InlineKeyboardButton('ğŸ” TOP 200 (~40s)', callback_data=f'scan_{scan_type}_200')],
        [InlineKeyboardButton('ğŸ’ WSZYSTKIE (~2min)', callback_data=f'scan_{scan_type}_all')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='scan_extremes')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def handle_scan(query, user_id, user, scan_type, scan_size=50):
    """Handle scanning"""
    exchange = user.get('selected_exchange', 'mexc').lower()
    interval = user.get('interval', '15m')
    await query.edit_message_text(f"ğŸ” SkanujÄ™ {EXCHANGES[exchange]['name']}...\n\nCzekaj...")
    try:
        logger.error(f"ğŸ”¥ KROK 2: Pobieram symbole z {exchange}")
        symbols = await exchange_api.get_symbols(exchange)
        logger.error(f"ğŸ”¥ KROK 3: Pobrano {len(symbols)} symboli")
        if not symbols:
            await query.edit_message_text("âŒ BÅ‚Ä…d pobierania par", reply_markup=back_button('scan_extremes'))
            return
        results = []
        # Limit do wybranego rozmiaru
        scan_limit = min(scan_size, len(symbols)) if scan_size < 9999 else len(symbols)
        logger.info(f'Scanning {scan_limit}/{len(symbols)} pairs')
        for symbol in list(symbols)[:scan_limit]:
            try:
                data = await exchange_api.get_ohlcv(symbol, exchange, interval)
                if not data or len(data) < 2:
                    continue
                current_price = data[-1][4]
                prev_price = data[-2][4]
                change_pct = ((current_price - prev_price) / prev_price) * 100
                closes = [candle[4] for candle in data[-14:]]
                gains = [closes[i] - closes[i-1] for i in range(1, len(closes)) if closes[i] > closes[i-1]]
                losses = [closes[i-1] - closes[i] for i in range(1, len(closes)) if closes[i] < closes[i-1]]
                avg_gain = sum(gains) / len(gains) if gains else 0
                avg_loss = sum(losses) / len(losses) if losses else 0
                if avg_loss == 0:
                    rsi = 100
                else:
                    rs = avg_gain / avg_loss
                    rsi = 100 - (100 / (1 + rs))
                volume = data[-1][5]
                result = {
                    'symbol': symbol,
                    'price': current_price,
                    'change': change_pct,
                    'rsi': rsi,
                    'volume': volume
                }
                if scan_type == 'scan_gainers' and change_pct > 0:
                    results.append(result)
                elif scan_type == 'scan_losers' and change_pct < 0:
                    results.append(result)
                elif scan_type == 'scan_rsi_oversold' and rsi < 20:
                    results.append(result)
                elif scan_type == 'scan_rsi_overbought' and rsi > 80:
                    results.append(result)
                elif scan_type == 'scan_volume':
                    results.append(result)
            except Exception as e:
                logger.error(f"Scan error for {symbol}: {e}")
                continue
        logger.error(f"ğŸ”¥ KROK 5: Skanowanie zakoÅ„czone, results={len(results)}")
        
        # SORTUJ po confidence (najlepsze pierwsze)
        results.sort(key=lambda x: x.get('confidence', 0), reverse=True)
        logger.error(f"ğŸ”¥ Po sortowaniu - najlepszy: {results[0]['symbol'] if results else 'BRAK'} {results[0].get('confidence', 0) if results else 0}%")
        
        # ZAPISZ DO TRACKER - learning database!
        from ai_signals_tracker import tracker
        saved_count = 0
        for r in results[:10]:  # Top 10 do bazy
            try:
                signal_id = tracker.record_signal(
                    symbol=r['symbol'],
                    exchange=exchange,
                    timeframe=timeframe,
                    signal=r['signal'],
                    confidence=r['confidence'],
                    price=r['entry'],
                    indicators={
                        'mtf_boost': r.get('mtf_boost', 0),
                        'htf_aligned': r.get('htf_aligned', False),
                        'ltf_aligned': r.get('ltf_aligned', False),
                        'tp1': r['tp1'],
                        'tp2': r['tp2'],
                        'tp3': r['tp3'],
                        'sl': r['sl']
                    },
                    ai_response=f"MTF Signal: {r['signal']} {r['confidence']}% (boost: +{r.get('mtf_boost', 0)}%, HTF: {r.get('htf_aligned', False)}, LTF: {r.get('ltf_aligned', False)})"
                )
                if signal_id:
                    saved_count += 1
            except Exception as e:
                logger.error(f"Failed to save signal {r['symbol']}: {e}")
        
        logger.info(f"ğŸ’¾ Saved {saved_count}/{len(results[:10])} AI signals to tracker")
        
        if not results:
            await query.edit_message_text("âŒ Brak wynikÃ³w", reply_markup=back_button('scan_extremes'))
            return
        if scan_type in ['scan_gainers', 'scan_losers']:
            results.sort(key=lambda x: abs(x['change']), reverse=True)
        elif scan_type in ['scan_rsi_oversold', 'scan_rsi_overbought']:
            results.sort(key=lambda x: x['rsi'])
        elif scan_type == 'scan_volume':
            results.sort(key=lambda x: x['volume'], reverse=True)
        top_results = results[:10]
        # Get user language
        lang = get_user_language(user)
        scan_names = {
            'scan_gainers': f"ğŸš€ {t('gainers', lang)}",
            'scan_losers': f"ğŸ“‰ {t('losers', lang)}",
            'scan_rsi_oversold': f"ğŸ”¥ {t('rsi_oversold', lang)}",
            'scan_rsi_overbought': f"ğŸ’ {t('rsi_overbought', lang)}",
            'scan_volume': f"ğŸ“ˆ {t('volume_top', lang)}"
        }
        text = f"{scan_names.get(scan_type, 'SKANER')}\n{EXCHANGES[exchange]['name']} | {TIMEFRAMES[interval]['label']}\n\n"
        text += f"{t('found_pairs', lang)}: {len(results)} {t('pairs', lang)}\n{t('top_10', lang)}:\n"
        keyboard = []
        for r in top_results:
            display_symbol = r["symbol"].replace(":USDT", "")
            symbol = display_symbol
            price = r['price']
            change = r['change']
            rsi = r['rsi']
            if scan_type in ['scan_gainers', 'scan_losers']:
                label = f"{'ğŸŸ¢' if change > 0 else 'ğŸ”´'} {symbol} | {change:+.2f}%"
            else:
                label = f"ğŸ“Š {symbol} | RSI {rsi:.0f}"
            symbol_encoded = symbol.replace("/", "_").replace(":", "_"); keyboard.append([InlineKeyboardButton(label, callback_data=f"analyze_{symbol_encoded}_{user.get('interval', '15m')}")])
        keyboard.append([InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data=scan_type)])
        keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='scan_extremes')])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        user['signals_count'] = user.get('signals_count', 0) + 1
        db.update_user(user_id, user)
    except Exception as e:
        logger.error(f"Scan error: {e}")
        await query.edit_message_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button('scan_extremes'))
# ==========================================
# SETTINGS
# ==========================================
async def settings_menu(query, user_id, user):
    """Settings menu"""
    exchange = user.get('selected_exchange', 'mexc').lower()
    interval = user.get('interval', '15m')
    lang = get_user_language(user)
    text = f"""âš™ï¸ {t('settings', lang).upper()}
ğŸŒ {t('exchange', lang)}: {EXCHANGES[exchange]['name']}
â° {t('interval', lang)}: {TIMEFRAMES[interval]['label']}"""
    keyboard = [
        [InlineKeyboardButton("ğŸŒ JÄ™zyk / Language", callback_data='language_menu')],
        [InlineKeyboardButton(t('change_exchange', lang), callback_data='change_exchange')],
        [InlineKeyboardButton(t('change_interval', lang), callback_data='change_interval')],
        [InlineKeyboardButton(t('back', lang), callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def change_exchange_menu(query, user_id, user):
    """Change exchange"""
    text = "ğŸŒ WYBIERZ GIEÅDÄ˜\n\nDostÄ™pne gieÅ‚dy:"
    keyboard = []
    for ex_id, ex_data in EXCHANGES.items():
        keyboard.append([InlineKeyboardButton(f"{ex_data['name']}", callback_data=f'set_exchange_{ex_id}')])
    keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='settings')])
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def change_interval_menu(query, user_id, user):
    """Change interval"""
    text = "â°  WYBIERZ INTERWAÅ"
    keyboard = [
        [InlineKeyboardButton('1m', callback_data='set_interval_1m'), InlineKeyboardButton('5m', callback_data='set_interval_5m'), InlineKeyboardButton('15m', callback_data='set_interval_15m')],
        [InlineKeyboardButton('30m', callback_data='set_interval_30m'), InlineKeyboardButton('1h', callback_data='set_interval_1h'), InlineKeyboardButton('4h', callback_data='set_interval_4h')],
        [InlineKeyboardButton('8h', callback_data='set_interval_8h'), InlineKeyboardButton('1d', callback_data='set_interval_1d'), InlineKeyboardButton('1w', callback_data='set_interval_1w')],
        [InlineKeyboardButton('1M', callback_data='set_interval_1M')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
# SUBSCRIPTION
# ==========================================
async def subscription_menu(query, user_id, user):
    """Subscription menu"""
    sub_status = format_subscription_status(user.get('subscription_end'), user.get('is_blocked', False))
    text = f"""ğŸ’ SUBSKRYPCJA
ğŸ†” ID: {user_id}
ğŸ“… Status: {sub_status}
âœ¨ PREMIUM:
â€¢ ğŸ¯ Nielimitowane sygnaÅ‚y AI
â€¢ ğŸ”” Nielimitowane alerty
â€¢ ğŸ“Š 16 timeframe'Ã³w
â€¢ ğŸš€ Priorytet wsparcia
ğŸ’° PAKIETY:
â€¢ 7 dni - 50 PLN / 12 USDT
â€¢ 30 dni - 150 PLN / 35 USDT â­
â€¢ 90 dni - 350 PLN / 80 USDT ğŸ”¥ -20%
â€¢ 365 dni - 1000 PLN / 230 USDT ğŸ’ -50%
ğŸ’¬ Kontakt: @YOUR_ADMIN"""
    keyboard = [
        [InlineKeyboardButton("ğŸ’³ Metody pÅ‚atnoÅ›ci", callback_data='payment_info')],
        [InlineKeyboardButton("ğŸ’¬ Kontakt z adminem", callback_data='admin_chat')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def payment_info_menu(query, user_id, user):
    """Payment info"""
    text = f"""ğŸ’³ METODY PÅATNOÅšCI

ğŸ’ USDT (TRC20) - TRON
Adres: `{USDT_ADDRESS}`

ğŸ“ JAK OPÅACIÄ†:
1. Wybierz pakiet (7/30/90/365 dni)
2. Kliknij "Kontakt z adminem"
3. Podaj wybrany pakiet
4. WyÅ›lij USDT na adres powyÅ¼ej
5. PrzeÅ›lij admina screenshot TX
6. Aktywacja w ciÄ…gu 24h!

âš¡ WAÅ»NE:
â€¢ Tylko USDT TRC20 (sieÄ‡ TRON)
â€¢ Podaj swoje ID: {user_id}
â€¢ Zachowaj potwierdzenie transakcji"""
    keyboard = [
        [InlineKeyboardButton("ğŸ’¬ Kontakt z adminem", callback_data='admin_chat')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='subscription')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
# ==========================================
# ALERTS
# ==========================================
async def alerts_menu(query, user_id, user):
    """Alerts menu"""
    text = """ğŸ”” ALERTY
Funkcja w przygotowaniu!
WkrÃ³tce dostÄ™pne:
â€¢ ğŸ’° Alert cenowy
â€¢ ğŸ“Š Alert RSI
â€¢ ğŸ“ˆ Alert MACD
Zostaniesz powiadomiony! ğŸš€"""
    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
# ADMIN CHAT
# ==========================================
async def admin_chat_menu(query, user_id, user):
    """Admin chat"""
    text = f"""ğŸ’¬ CZAT Z ADMINEM
ğŸ†” Twoje ID: {user_id}
Napisz swojÄ… wiadomoÅ›Ä‡ w nastÄ™pnej wiadomoÅ›ci.
Admin odpowie bezpoÅ›rednio.
ğŸ“ MoÅ¼esz wysÅ‚aÄ‡:
â€¢ Tekst
â€¢ ZdjÄ™cia
â€¢ Dokumenty"""
    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    user['awaiting_admin_message'] = True
    db.update_user(user_id, user)
# ==========================================
# ADMIN PANEL
# ==========================================
async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle text messages - search pairs or admin messages"""
    user_id = update.effective_user.id
    user = db.get_user(user_id)

    # Check if admin is writing broadcast (MUST BE FIRST!)
    if user.get('awaiting_broadcast'):
        message_text = update.message.text
        
        if message_text == '/cancel':
            user['awaiting_broadcast'] = False
            db.update_user(user_id, user)
            await update.message.reply_text("âŒ Anulowano")
            return
    
    # Check if admin is writing message to specific user
    target_uid = user.get('awaiting_admin_message')
    if target_uid:
        message_text = update.message.text
        
        if message_text == '/cancel':
            user['awaiting_admin_message'] = None
            db.update_user(user_id, user)
            await update.message.reply_text("âŒ Anulowano")
            return
        
        # Clear state
        user['awaiting_admin_message'] = None
        db.update_user(user_id, user)
        
        await admin_msg_send(update, context, target_uid, message_text)
        return
        
        await admin_broadcast_confirm(update, context, message_text)
        return
    
    if not user:
        await update.message.reply_text("âŒ WyÅ›lij /start aby rozpoczÄ…Ä‡")
        return
    if user.get('awaiting_admin_message'):
        await handle_admin_message_forward(update, context, user_id, user)
        return
    search_term = update.message.text.strip().upper()
    exchange = user.get('selected_exchange', 'mexc').lower()
    await update.message.reply_text(f"ğŸ” Szukam '{search_term}' na {EXCHANGES[exchange]['name']}...")
    try:
        logger.error(f"ğŸ”¥ KROK 2: Pobieram symbole z {exchange}")
        symbols = await exchange_api.get_symbols(exchange)
        logger.error(f"ğŸ”¥ KROK 3: Pobrano {len(symbols)} symboli")
        if not symbols:
            await update.message.reply_text("âŒ BÅ‚Ä…d pobierania par", reply_markup=back_button())
            return
        matching = [s for s in symbols if search_term in s.upper()]
        if not matching:
            await update.message.reply_text(f"âŒ Nie znaleziono par zawierajÄ…cych '{search_term}'", reply_markup=back_button())
            return
        text = f"ğŸ” WYNIKI WYSZUKIWANIA\n\nZnaleziono: {len(matching)} par\n\n"
        keyboard = []
        for symbol in matching[:20]:
            display_symbol = symbol.replace(':USDT', '')
            symbol_encoded = symbol.replace("/", "_").replace(":", "_"); keyboard.append([InlineKeyboardButton(f"ğŸ“Š {display_symbol}", callback_data=f"analyze_{symbol_encoded}_{user.get('interval', '15m')}")])
        keyboard.append([InlineKeyboardButton('â¬…ï¸ Menu', callback_data='back_main')])
        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        logger.error(f"Search error: {e}")
        await update.message.reply_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button())
async def handle_admin_message_forward(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id, user):
    """Forward message to admin"""
    if not ADMIN_IDS:
        await update.message.reply_text("âŒ Brak skonfigurowanego admina")
        return
    admin_id = ADMIN_IDS[0]
    username = update.effective_user.username or "Brak username"
    first_name = update.effective_user.first_name or "User"
    try:
        header = f"ğŸ’¬ WiadomoÅ›Ä‡ od:\n\n"
        header += f"ğŸ‘¤ {first_name} (@{username})\n"
        header += f"ğŸ†” ID: {user_id}\n"
        header += f"{'='*30}\n\n"
        await context.bot.send_message(chat_id=admin_id, text=header)
        await update.message.forward(admin_id)
        await update.message.reply_text(
            "âœ… WiadomoÅ›Ä‡ wysÅ‚ana!\n\nAdmin odpowie najszybciej jak to moÅ¼liwe.",
            reply_markup=back_button()
        )
        user['awaiting_admin_message'] = False
        db.update_user(user_id, user)
    except Exception as e:
        logger.error(f"Forward error: {e}")
        await update.message.reply_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button())
# ==========================================
# START FROM CALLBACK
# ==========================================
async def start_command_from_callback(query, user_id, user):
    """Start command from callback (recreate menu)"""
    sub_status = format_subscription_status(user.get('subscription_end'), user.get('is_blocked', False))
    lang = user.get('language', 'pl')
    is_admin = user_id in ADMIN_IDS
    welcome = f"""ğŸ‘‹ BOTrader Bot
Status: {sub_status}
ğŸ†” ID: {user_id}
âœ¨ Wpisz nazwÄ™ pary (np. BTC) aby wyszukaÄ‡
ğŸ“Š Lub uÅ¼yj menu poniÅ¼ej"""
    keyboard = [
        [InlineKeyboardButton("ğŸ” Wyszukaj parÄ™", callback_data="search_pair")],
        [InlineKeyboardButton("ğŸ“Š Skaner ekstremÃ³w", callback_data="scan_extremes")],
        [InlineKeyboardButton("ğŸ¯ SygnaÅ‚y AI", callback_data='ai_signals')],
        [InlineKeyboardButton("ğŸ”” Alerty", callback_data="alerts_menu")],
        [InlineKeyboardButton("ğŸ’¬ Czat z adminem", callback_data='admin_chat')],
        [InlineKeyboardButton("âš™ï¸ Ustawienia", callback_data="settings")],
        [InlineKeyboardButton("ğŸ’ Subskrypcja", callback_data='subscription')],
        [InlineKeyboardButton("â­ OceÅ„ bota", callback_data='rate_bot')]
    ]
    if is_admin:
        keyboard.append([InlineKeyboardButton("ğŸ‘‘ Admin Panel", callback_data="admin_panel")])
    keyboard.append([
        InlineKeyboardButton("ğŸ“Š MEXC", url='https://promote.mexc.com/r/gspEf2nl'),
        InlineKeyboardButton("ğŸ“Š Bybit", url='https://www.bybit.com/invite?ref=64NXL'),
        InlineKeyboardButton("ğŸ“Š Binance", url='https://www.binance.com/activity/referral-entry/CPA?ref=CPA_00J86WYYZV')
    ])
    # Delete old message and send new (fix cache)
    try:
        await query.message.delete()
        await query.message.chat.send_message(welcome, reply_markup=InlineKeyboardMarkup(keyboard))
    except:
        await query.edit_message_text(welcome, reply_markup=InlineKeyboardMarkup(keyboard))
logger.info("âœ… Handlers initialized")
# ==========================================
# SEARCH PAIR MENU
# ==========================================
async def search_pair_menu(query, user_id, user):
    """Search pair menu"""
    text = """ğŸ” WYSZUKAJ PARÄ˜
Wpisz nazwÄ™ kryptowaluty (np. BTC, ETH, SOL)
Bot znajdzie wszystkie pary z USDT na wybranej gieÅ‚dzie.
ğŸ’¡ MoÅ¼esz teÅ¼ wpisaÄ‡ nazwÄ™ w dowolnym momencie bez klikania tego przycisku!"""
    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    user['awaiting_search'] = True
    db.update_user(user_id, user)
# ==========================================
# AI SIGNALS MENU
# ==========================================
async def ai_signals_menu(query, user_id, user):
    """AI Signals menu"""
    text = """ğŸ¯ SYGNAÅY AI
Wybierz timeframe:
Bot przeanalizuje TOP pary uÅ¼ywajÄ…c:
â€¢ DeepSeek AI - analiza techniczna
â€¢ RSI, MACD, Volume
â€¢ Support/Resistance
â€¢ Rekomendacje TP1/TP2/TP3"""
    keyboard = [
        [InlineKeyboardButton("ğŸ“Š 15m", callback_data='ai_15m'), InlineKeyboardButton("ğŸ“Š 1h", callback_data='ai_1h')],
        [InlineKeyboardButton("ğŸ“Š 4h", callback_data='ai_4h'), InlineKeyboardButton("ğŸ“Š 1d", callback_data='ai_1d')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
# RATE BOT MENU
# ==========================================
async def rate_bot_menu(query, user_id, user):
    """Rate bot menu"""
    text = """â­ OCEÅƒ BOTA
PomÃ³Å¼ nam siÄ™ rozwijaÄ‡!
ğŸ“ Twoja opinia:
â€¢ Co dziaÅ‚a Å›wietnie?
â€¢ Co moÅ¼na poprawiÄ‡?
â€¢ Jakie funkcje dodaÄ‡?
ğŸ’¬ Napisz swojÄ… opiniÄ™ w nastÄ™pnej wiadomoÅ›ci lub kliknij poniÅ¼ej:"""
    keyboard = [
        [InlineKeyboardButton("â­â­â­â­â­ Åšwietny!", callback_data='rate_5')],
        [InlineKeyboardButton("â­â­â­â­ Dobry", callback_data='rate_4')],
        [InlineKeyboardButton("â­â­â­ OK", callback_data='rate_3')],
        [InlineKeyboardButton("ğŸ’¬ Napisz opiniÄ™", callback_data='admin_chat')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
logger.info("âœ… New menu handlers added")
# ==========================================
# ADVANCED AI SIGNALS
# ==========================================
async def ai_signals_menu_advanced(query, user_id, user):
    """Advanced AI Signals menu"""
    exchange = user.get('selected_exchange', 'mexc').lower()
    text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
â± Wybierz TIMEFRAME:
(czas w jakim sygnaÅ‚ siÄ™ sprawdzi)
ğŸ“Š Skanowanie z filtrami:
â€¢ Volume + Volatility + LikwidnoÅ›Ä‡
â€¢ Multi-timeframe analysis
â€¢ DeepSeek AI + wskaÅºniki"""
    keyboard = [
        [InlineKeyboardButton("âš¡ 1m", callback_data='ai_scan_1m'), InlineKeyboardButton("âš¡ 3m", callback_data='ai_scan_3m'), InlineKeyboardButton("âš¡ 5m", callback_data='ai_scan_5m')],
        [InlineKeyboardButton("ğŸ“Š 15m", callback_data='ai_scan_15m'), InlineKeyboardButton("ğŸ“Š 30m", callback_data='ai_scan_30m'), InlineKeyboardButton("ğŸ“Š 1h", callback_data='ai_scan_1h')],
        [InlineKeyboardButton("ğŸ“ˆ 2h", callback_data='ai_scan_2h'), InlineKeyboardButton("ğŸ“ˆ 4h", callback_data='ai_scan_4h'), InlineKeyboardButton("ğŸ“ˆ 8h", callback_data='ai_scan_8h')],
        [InlineKeyboardButton("ğŸ”¥ 12h", callback_data='ai_scan_12h'), InlineKeyboardButton("ğŸ”¥ 1d", callback_data='ai_scan_1d'), InlineKeyboardButton("ğŸ”¥ 3d", callback_data='ai_scan_3d')],
        [InlineKeyboardButton("ğŸ’ 1w", callback_data='ai_scan_1w'), InlineKeyboardButton("ğŸ’ 2w", callback_data='ai_scan_2w'), InlineKeyboardButton("ğŸ’ 1M", callback_data='ai_scan_1M')],
        [InlineKeyboardButton("âš™ï¸ Ustawienia skanowania", callback_data='ai_scan_settings')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def ai_scan_settings_menu(query, user_id, user):
    """Scan settings"""
    text = """âš™ï¸ USTAWIENIA SKANOWANIA
Wybierz ile par przeskanowaÄ‡:
ğŸ’¡ WiÄ™ksza liczba = wiÄ™cej sygnaÅ‚Ã³w
âš ï¸ WiÄ™ksza liczba = dÅ‚uÅ¼sze skanowanie"""
    keyboard = [
        [InlineKeyboardButton("ğŸ”Ÿ TOP 10 par", callback_data='ai_size_top10')],
        [InlineKeyboardButton("5ï¸âƒ£0ï¸âƒ£ TOP 50 par", callback_data='ai_size_top50')],
        [InlineKeyboardButton("ğŸ’¯ TOP 100 par", callback_data='ai_size_top100')],
        [InlineKeyboardButton("2ï¸âƒ£0ï¸âƒ£0ï¸âƒ£ TOP 200 par", callback_data='ai_size_top200')],
        [InlineKeyboardButton("3ï¸âƒ£0ï¸âƒ£0ï¸âƒ£ TOP 300 par", callback_data='ai_size_top300')],
        [InlineKeyboardButton("ğŸŒ WSZYSTKIE pary", callback_data='ai_size_all')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def ai_scan_select_size(query, user_id, user, timeframe):
    """Select scan size before scanning"""
    exchange = user.get('selected_exchange', 'mexc').lower()
    text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
â± Timeframe: {timeframe}
ğŸ“Š WYBIERZ ZAKRES SKANOWANIA:
ğŸ” TOP 10/50 = NajwiÄ™ksze kryptowaluty (BTC, ETH, SOL...)
ğŸ“Š 100+ = Wszystkie dostÄ™pne pary na gieÅ‚dzie
ğŸ’¡ WiÄ™cej par = wiÄ™cej sygnaÅ‚Ã³w
âš ï¸ WiÄ™cej par = dÅ‚uÅ¼sze skanowanie"""
    keyboard = [
        [InlineKeyboardButton("ğŸ” TOP 10 crypto (~5s)", callback_data=f'ai_run_{timeframe}_top10')],
        [InlineKeyboardButton("ğŸ” TOP 50 crypto (~20s)", callback_data=f'ai_run_{timeframe}_top50')],
        [InlineKeyboardButton("ğŸ“Š TOP 100 par (~40s)", callback_data=f'ai_run_{timeframe}_top100')],
        [InlineKeyboardButton("ğŸ“Š TOP 200 par (~80s)", callback_data=f'ai_run_{timeframe}_top200')],
        [InlineKeyboardButton("ğŸ“Š TOP 500 par (~3min)", callback_data=f'ai_run_{timeframe}_top500')],
        [InlineKeyboardButton("ğŸŒ WSZYSTKIE pary (~5min)", callback_data=f'ai_run_{timeframe}_all')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def ai_scan_speed_choice(query, user_id, user, timeframe, scan_size):
    """WybÃ³r szybkoÅ›ci skanowania: szybkie (wskaÅºniki) vs dokÅ‚adne (AI)"""
    text = f"""âš¡ WYBIERZ TRYB SKANOWANIA

ğŸ¯ Timeframe: {timeframe}
ğŸ“Š Zakres: {scan_size.upper()}

ğŸš€ **SZYBKIE** (30-60 sek)
â€¢ Tylko wskaÅºniki techniczne
â€¢ Bez DeepSeek AI
â€¢ Szybsze wyniki
â€¢ Wszystko trafia do uczenia

ğŸ¯ **DOKÅADNE** (2-5 min)
â€¢ PeÅ‚na analiza AI
â€¢ DeepSeek reasoning
â€¢ WyÅ¼sza jakoÅ›Ä‡ sygnaÅ‚Ã³w
â€¢ Wszystko trafia do uczenia

KtÃ³ry tryb?"""
    
    keyboard = [
        [InlineKeyboardButton('ğŸš€ Szybkie (wskaÅºniki)', callback_data=f'ai_fast_{timeframe}_{scan_size}')],
        [InlineKeyboardButton('ğŸ¯ DokÅ‚adne (AI)', callback_data=f'ai_full_{timeframe}_{scan_size}')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')


async def ai_scan_execute(query, user_id, user, timeframe, scan_size="top10"):
    """Execute AI scan with TILES"""
    logger.error(f"ğŸ”¥ğŸ”¥ğŸ”¥ AI_SCAN_EXECUTE WYWOÅANE! TF={timeframe}, size={scan_size}")
    exchange = user.get('selected_exchange', 'mexc').lower()
    await query.edit_message_text(f"""ğŸ¤– SKANOWANIE AI...
â± Timeframe: {timeframe}
ğŸŒ GieÅ‚da: {EXCHANGES[exchange]['name']}
ğŸ“Š Zakres: {scan_size.upper()}
â³ ProszÄ™ czekaÄ‡...""")
    try:
        # Pobierz symbole z gieÅ‚dy
        logger.error("ğŸ”¥ KROK 1: UÅ¼ywam globalnego exchange_api")
        # from exchanges import exchange_api  # USUNIÄ˜TE - byÅ‚ zÅ‚y
        logger.error(f"ğŸ”¥ KROK 2: Pobieram symbole z {exchange}")
        symbols = await exchange_api.get_symbols(exchange)
        logger.error(f"ğŸ”¥ KROK 3: Pobrano {len(symbols)} symboli")
        
        # Filtruj wedÅ‚ug rozmiaru
        if scan_size == 'top10':
            symbols = symbols[:10]
        elif scan_size == 'top25':
            symbols = symbols[:25]
        elif scan_size == 'top50':
            symbols = symbols[:50]
        elif scan_size == 'top100':
            symbols = symbols[:100]
        
        # Skanuj kaÅ¼dy symbol uÅ¼ywajÄ…c central_analyzer
        results = []
        scanned = 0
        total_to_scan = int(scan_size.replace('top', ''))
        for symbol in symbols[:total_to_scan]:
            scanned += 1
            if scanned % 10 == 0:
                try:
                    await query.edit_message_text(f"ğŸ¤– Skanowanie: {scanned}/{total_to_scan} par...")
                except:
                    pass
            try:
                # SprawdÅº tryb skanowania
                scan_mode = user.get('scan_mode', 'full')
                
                if scan_mode == 'fast':
                    # SZYBKIE - tylko wskaÅºniki, bez DeepSeek
                    result = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe, 'ai_signals_fast', language=get_user_language(user), skip_ai=True)
                    # Konwertuj format na compatible z MTF
                    if result and result.get('signal'):
                        sig = result['signal']
                        direction = sig.get('direction', 'NEUTRAL')
                        if direction != 'NEUTRAL':  # Tylko LONG/SHORT
                            result = {
                                'symbol': symbol,
                                'timeframe': timeframe,
                                'signal': direction,
                                'confidence': sig.get('confidence', 50),
                                'entry': result.get('current_price', 0),
                                'tp1': sig.get('tp1', 0),
                                'tp2': sig.get('tp2', 0),
                                'tp3': sig.get('tp3', 0),
                                'sl': sig.get('sl', 0),
                                'mtf_boost': 0,
                                'validation': {'htf_aligned': False, 'ltf_aligned': False}
                            }
                        else:
                            result = None
                    else:
                        result = None
                else:
                    # PEÅNE - z AI
                    result = await central_analyzer.analyze_for_ai_signals(symbol, timeframe, exchange, language=get_user_language(user))
                
                if result:  # Akceptuj WSZYSTKO (nawet nisko)
                    if result.get('signal') != 'NEUTRAL':  # Filtruj NEUTRAL w DOKÅADNYM
                        results.append({
                        'symbol': result['symbol'],
                        'signal': result['signal'],
                        'confidence': result['confidence'],
                        'entry': result['entry'],
                        'tp1': result['tp1'],
                        'tp2': result['tp2'],
                        'tp3': result['tp3'],
                        'sl': result['sl'],
                        'mtf_boost': result.get('mtf_boost', 0),
                        'htf_aligned': result['validation']['htf_aligned'],
                        'ltf_aligned': result['validation']['ltf_aligned']
                    })
            except Exception as e:
                logger.debug(f"Skip {symbol}: {e}")
                continue
        
        logger.error(f"ğŸ”¥ KROK 5: Skanowanie zakoÅ„czone, results={len(results)}")
        
        # SORTUJ po confidence (najlepsze pierwsze)
        results.sort(key=lambda x: x.get('confidence', 0), reverse=True)
        logger.error(f"ğŸ”¥ Po sortowaniu - najlepszy: {results[0]['symbol'] if results else 'BRAK'} {results[0].get('confidence', 0) if results else 0}%")
        
        # ZAPISZ DO TRACKER - learning database!
        from ai_signals_tracker import tracker
        saved_count = 0
        for r in results[:10]:  # Top 10 do bazy
            try:
                signal_id = tracker.record_signal(
                    symbol=r['symbol'],
                    exchange=exchange,
                    timeframe=timeframe,
                    signal=r['signal'],
                    confidence=r['confidence'],
                    price=r['entry'],
                    indicators={
                        'mtf_boost': r.get('mtf_boost', 0),
                        'htf_aligned': r.get('htf_aligned', False),
                        'ltf_aligned': r.get('ltf_aligned', False),
                        'tp1': r['tp1'],
                        'tp2': r['tp2'],
                        'tp3': r['tp3'],
                        'sl': r['sl']
                    },
                    ai_response=f"MTF Signal: {r['signal']} {r['confidence']}% (boost: +{r.get('mtf_boost', 0)}%, HTF: {r.get('htf_aligned', False)}, LTF: {r.get('ltf_aligned', False)})"
                )
                if signal_id:
                    saved_count += 1
            except Exception as e:
                logger.error(f"Failed to save signal {r['symbol']}: {e}")
        
        logger.info(f"ğŸ’¾ Saved {saved_count}/{len(results[:10])} AI signals to tracker")
        
        if not results:
            await query.edit_message_text("âŒ Brak sygnaÅ‚Ã³w speÅ‚niajÄ…cych kryteria", reply_markup=back_button('ai_signals'))
            return
                # Get page for pagination
        page = user.get('ai_current_page', 1)
        per_page = 10
        total_pages = (len(results) + per_page - 1) // per_page
        
        # Tekst nagÅ‚Ã³wka z pagination
        text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
â± Timeframe: {timeframe}
ğŸ“Š Znaleziono: {len(results)} sygnaÅ‚Ã³w (Strona {page}/{total_pages})
ğŸ’¡ Kliknij parÄ™ aby zobaczyÄ‡ peÅ‚nÄ… analizÄ™ AI!
"""
        # Pagination already defined above
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        page_results = results[start_idx:end_idx]
        
        # KAFELKI
        keyboard = []
        for r in page_results:
            emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´"
            clean_symbol = r['symbol'].replace('/USDT:USDT', '').replace(':USDT', '')
            display_symbol = r["symbol"].replace(":USDT", "")
            label = f"{emoji} {display_symbol} | {r['signal']} {int(r['confidence'])}%"
            # Dodaj marker context: ai_sig_
            keyboard.append([InlineKeyboardButton(label, callback_data=f'ai_sig_{clean_symbol}_{timeframe}')])
        # Nawigacja stron
        nav_row = []
        if page > 1:
            nav_row.append(InlineKeyboardButton('â—€ï¸ Poprzednia', callback_data=f'ai_page_{page-1}'))
        if page < total_pages:
            nav_row.append(InlineKeyboardButton('NastÄ™pna â–¶ï¸', callback_data=f'ai_page_{page+1}'))
        
        if nav_row:
            keyboard.append(nav_row)
        
        # Przyciski akcji
        keyboard.append([InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data=f'ai_run_{timeframe}_{scan_size}')])
        keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        # Zapisz context dla przycisku powrÃ³t
        user['signals_count'] = user.get('signals_count', 0) + len(results)
        user['last_scan_size'] = scan_size
        user['last_timeframe'] = timeframe
        user['cached_scan_results'] = [
            {
                'symbol': r['symbol'],
                'signal': r['signal'],
                'confidence': int(r['confidence']),
                'entry': r['entry'],
                'tp1': r['tp1'],
                'tp2': r['tp2'],
                'tp3': r['tp3'],
                'sl': r['sl'],
                'mtf_boost': r.get('mtf_boost', 0),
                'htf_aligned': r.get('htf_aligned', False),
                'ltf_aligned': r.get('ltf_aligned', False)
            }
            for r in results  # WSZYSTKIE (nie [:10])
        ]
        user['ai_current_page'] = 1  # Reset do strony 1
        logger.info(f"Cached {len(user['cached_scan_results'])} results")
        user['last_scan_size'] = scan_size
        db.update_user(user_id, user)
    except Exception as e:
        logger.error(f"AI scan error: {e}")
        await query.edit_message_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button('ai_signals'))
logger.info("âœ… Advanced AI Signals handlers added")
# ==========================================
# CENTRALNY ANALYZER - DETAILED VIEW
# ==========================================
from analyzer_wrapper import analyzer_with_learning as central_analyzer
from languages import t, get_user_language, TRANSLATIONS

async def show_ai_signal_detail(query, user_id, user, symbol, timeframe, mtf_data=None):
    """Show AI Signal with MTF TP/SL"""
    lang = get_user_language(user)
    exchange = user.get('selected_exchange', 'mexc')
    
    await query.edit_message_text('â³ ÅadujÄ™ analizÄ™ AI...')
    
    try:
        # JeÅ›li mamy MTF data - uÅ¼yj ich!
        if mtf_data and 'tp1' in mtf_data:
            # Formatuj z MTF TP/SL
            signal = mtf_data['signal']
            confidence = mtf_data['confidence']
            entry = mtf_data['entry']
            tp1 = mtf_data['tp1']
            tp2 = mtf_data['tp2']
            tp3 = mtf_data['tp3']
            sl = mtf_data['sl']
            
            mtf_boost = mtf_data.get('mtf_boost', 0)
            htf_aligned = mtf_data.get('htf_aligned', False)
            ltf_aligned = mtf_data.get('ltf_aligned', False)
            
            # Format ceny
            from format_price import format_price
            
            emoji = 'ğŸŸ¢' if signal == 'LONG' else 'ğŸ”´' if signal == 'SHORT' else 'âšª'
            
            text = f"""{emoji} SYGNAÅ AI - {symbol.split('/')[0]}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ SYGNAÅ: {signal} ({confidence}%)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’° ENTRY: {format_price(entry)}
ğŸ¯ TARGETY:
â€¢ TP1: {format_price(tp1)} (+{((tp1-entry)/entry*100):.2f}%)
â€¢ TP2: {format_price(tp2)} (+{((tp2-entry)/entry*100):.2f}%)
â€¢ TP3: {format_price(tp3)} (+{((tp3-entry)/entry*100):.2f}%)
ğŸ›‘ STOP LOSS: {format_price(sl)} ({((sl-entry)/entry*100):.2f}%)

â± Timeframe: {timeframe} | ğŸŒ {exchange.upper()}

ğŸ” MULTI-TIMEFRAME VALIDATION:
â€¢ Base confidence: {confidence - mtf_boost}%
â€¢ MTF Boost: +{mtf_boost}%
â€¢ HTF aligned: {'âœ…' if htf_aligned else 'âŒ'}
â€¢ LTF aligned: {'âœ…' if ltf_aligned else 'âŒ'}

ğŸ’¡ SygnaÅ‚ ma siÄ™ sprawdziÄ‡ w ciÄ…gu ~{timeframe}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ To NIE jest porada finansowa!
Zawsze przeprowadzaj wÅ‚asnÄ… analizÄ™.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"""
            
        else:
            # Fallback - peÅ‚na analiza
            analysis = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe, 'ai_sig_detail', language=get_user_language(user))
            text = format_analysis_report(analysis, lang)
        
        # Przyciski
        keyboard = [
            [InlineKeyboardButton('ğŸ“Š Wykres', callback_data=f'chart_{symbol}_{timeframe}')],
            [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')],
            [InlineKeyboardButton('ğŸ  Menu', callback_data='back_main')]
        ]
        
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        
    except Exception as e:
        logger.error(f"show_ai_signal_detail error: {e}", exc_info=True)
        await query.edit_message_text(
            f"âŒ BÅ‚Ä…d: {e}",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]])
        )

async def show_cached_scan(query, user_id, user):
    """Show cached scan results"""
    # Pobierz Å›wieÅ¼y user z DB (z zapisanym cache)
    user = db.get_user(user_id)
    cached = user.get('cached_scan_results')
    if not cached or len(cached) == 0:
        logger.info(f"No cache - pokazujÄ™ menu AI Signals")
        # PokaÅ¼ menu AI Signals zamiast automatycznego skanowania
        await query.answer("Brak zapisanych wynikÃ³w. Wybierz skanowanie.", show_alert=True)
        await ai_signals_menu(query, user_id, user)
        return
    logger.info(f"Showing {len(cached)} cached results")
    timeframe = user.get('last_timeframe', '30m')
    scan_size = user.get('last_scan_size', 'top50')
    exchange = user.get('selected_exchange', 'mexc')
    size_labels = {
        'top10': 'TOP10', 'top20': 'TOP20', 'top30': 'TOP30',
        'top50': 'TOP50', 'top100': 'TOP100', 'all': 'WSZYSTKIE'
    }
    tf_labels = {'15m': '15 minut', '30m': '30 minut', '1h': '1 godzina', '4h': '4 godziny'}
    text = f"""ğŸ¯ SYGNAÅY AI - {exchange.upper()}
â± Timeframe: {tf_labels.get(timeframe, timeframe)}
ğŸ“Š Zakres: {size_labels.get(scan_size, scan_size.upper())}
ğŸ” Znaleziono: {len(cached)} sygnaÅ‚Ã³w
{"="*30}
"""
    for i, r in enumerate(cached[:10], 1):
        emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´" if r['signal'] == 'SHORT' else "âšª"
        display_symbol = r['symbol'].replace(":USDT", "")
        text += f"""{i}. {emoji} {display_symbol}
   {r['signal']} | PewnoÅ›Ä‡: {r['confidence']}%~
"""
    text += f"""{"="*30}
ğŸ’¡ Kliknij parÄ™ aby zobaczyÄ‡ szczegÃ³Å‚y
âš ï¸ %~ = wstÄ™pna ocena"""
    # Kafelki
    keyboard = []
    for r in cached[:10]:
        clean_symbol = r['symbol'].replace('/USDT:USDT', '').replace(':USDT', '')
        emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´"
        label = f"{emoji} {clean_symbol} | {r['signal']} {r['confidence']}%~"
        keyboard.append([InlineKeyboardButton(
            label, 
            callback_data=f"ai_sig_{clean_symbol}_{timeframe}"
        )])
    keyboard.append([InlineKeyboardButton('ğŸ”„ Skanuj ponownie', callback_data=f'ai_scan_tf_{timeframe}')])
    keyboard.append([InlineKeyboardButton('âš™ï¸ ZmieÅ„ ustawienia', callback_data='ai_scan_menu')])
    keyboard.append([InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')])
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, context='general'):
    """
    GÅÃ“WNA FUNKCJA - PokaÅ¼ peÅ‚nÄ… analizÄ™ pary
    WywoÅ‚ana z KAÅ»DEGO miejsca w bocie (search, scan, ai_signal)
    """
    # Show loading
    await query.edit_message_text(f"""ğŸ¤– ANALIZA AI - {symbol}
â³ AnalizujÄ™...
ğŸ“Š Pobieranie danych z gieÅ‚dy
ğŸ” Analiza techniczna (RSI, EMA, MACD...)
ğŸ“ˆ Wykrywanie struktur rynku
ğŸ’ DeepSeek AI reasoning
ğŸ“° Sprawdzanie newsÃ³w
ProszÄ™ czekaÄ‡ ~10 sekund...""")
    try:
        # CALL CENTRAL ANALYZER
        analysis = await central_analyzer.analyze_pair_full(
            exchange=exchange,
            symbol=symbol,
            timeframe=timeframe,
            context=context, language=get_user_language(user))
        if not analysis:
            # STEP 1: JeÅ›li FUTURES nie dziaÅ‚a, sprÃ³buj SPOT (ta sama para moÅ¼e byÄ‡ starsza na spot)
            if exchange == 'mexc' and ':USDT' in symbol:
                # To jest FUTURES, sprÃ³buj SPOT
                spot_symbol = symbol.replace(':USDT', '')  # BTC/USDT:USDT â†’ BTC/USDT
                logger.info(f"Futures failed, trying SPOT: {spot_symbol}")
                try:
                    analysis = await central_analyzer.analyze_pair_full(
                        exchange=exchange,
                        symbol=spot_symbol,
                        timeframe=timeframe,
                        context=context, language=get_user_language(user))
                    if analysis:
                        analysis['fallback_info'] = {
                            'original_market': 'FUTURES',
                            'used_market': 'SPOT',
                            'original_symbol': symbol,
                            'used_symbol': spot_symbol,
                            'reason': f"âš ï¸ Para {symbol} jest nowa na FUTURES lub brak danych.\nâœ… Znaleziono dane na rynku SPOT."
                        }
                        symbol = spot_symbol  # Update symbol dla display
                except Exception as e:
                    logger.error(f"SPOT fallback failed: {e}")
            # STEP 2: JeÅ›li nadal brak analizy, prÃ³buj inne timeframe'y
            if not analysis:
                # SMART FALLBACK - prÃ³buj inne timeframe'y jeÅ›li brak danych
                fallback_timeframes = ['15m', '1h', '4h', '1d']
            # UsuÅ„ aktualny timeframe z fallback
            if timeframe in fallback_timeframes:
                fallback_timeframes.remove(timeframe)
            # PrÃ³buj alternatywne timeframe'y
            for alt_tf in fallback_timeframes:
                logger.info(f"Trying fallback timeframe: {alt_tf}")
                analysis = await central_analyzer.analyze_pair_full(
                    exchange=exchange,
                    symbol=symbol,
                    timeframe=alt_tf,
                    context=context, language=get_user_language(user))
                if analysis:
                    # SUKCES - wyjaÅ›nij uÅ¼ytkownikowi
                    reason = ""
                    if timeframe in ['1m', '3m', '5m']:
                        reason = f"âš ï¸ Zbyt krÃ³tki interwaÅ‚ ({timeframe}) - para moÅ¼e byÄ‡ nowa lub brak wystarczajÄ…cych danych."
                    elif timeframe in ['1w', '1M']:
                        reason = f"âš ï¸ Zbyt dÅ‚ugi interwaÅ‚ ({timeframe}) - para moÅ¼e nie mieÄ‡ wystarczajÄ…cej historii."
                    else:
                        reason = f"âš ï¸ Brak danych dla interwaÅ‚u {timeframe} - para moÅ¼e byÄ‡ nowa lub nieaktywna."
                    # Dodaj info na poczÄ…tku analizy
                    analysis['fallback_info'] = {
                        'original_tf': timeframe,
                        'used_tf': alt_tf,
                        'reason': reason
                    }
                    timeframe = alt_tf  # Update dla dalszej czÄ™Å›ci
                    break
            if not analysis:
                await query.edit_message_text(
                    f"âŒ Nie udaÅ‚o siÄ™ przeanalizowaÄ‡ {symbol}\n\n"
                    f"PrÃ³bowano interwaÅ‚Ã³w: {timeframe}, {', '.join(fallback_timeframes)}\n\n"
                    f"MoÅ¼liwe przyczyny:\n"
                    f"â€¢ Para zbyt nowa (brak historii)\n"
                    f"â€¢ Nieaktywna para (brak wolumenu)\n"
                    f"â€¢ Problem z gieÅ‚dÄ…\n\n"
                    f"SprÃ³buj innej pary lub gieÅ‚dy.",
                reply_markup=back_button('back_main')
            )
            return
        # Build beautiful report with user's language
        lang = get_user_language(user)
        text = format_analysis_report(analysis, lang)
        # Buttons - context-aware back button
        clean_symbol = symbol.replace('/USDT', '').replace('/', '')
        # Determine back button based on context
        if context == 'ai_signal':
            back_data = 'show_cached_scan'
            back_label = 'â¬…ï¸ WrÃ³Ä‡ do sygnaÅ‚Ã³w'
        elif context == 'scan_extreme':
            back_data = f'scan_{user.get("last_scan_type", "gainers")}'
            back_label = 'â¬…ï¸ WrÃ³Ä‡ do skanera'
        elif context == 'search':
            back_data = 'back_main'
            back_label = 'â¬…ï¸ Menu gÅ‚Ã³wne'
        else:
            back_data = 'back_main'
            back_label = 'â¬…ï¸ Menu gÅ‚Ã³wne'
        keyboard = [
            [InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼ analizÄ™', callback_data=f'refresh_analysis_{symbol}_{timeframe}')],
            [InlineKeyboardButton(back_label, callback_data=back_data)]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        # Increment counter
        user['signals_count'] = user.get('signals_count', 0) + 1
        db.update_user(user_id, user)
    except Exception as e:
        logger.error(f"Analysis display error: {e}")
        await query.edit_message_text(
            f"âŒ BÅ‚Ä…d analizy: {e}",
            reply_markup=back_button('back_main')
        )
def generate_ai_summary(signal, technical, sentiment, lang='pl'):
    """Generate simple AI summary in user's language"""
    direction = signal['direction']
    confidence = signal['confidence']
    rsi = technical['rsi']['14']
    price = technical['price']
    # Templates for each language
    templates = {
        'pl': {
            'LONG': f"ğŸ“Š Analiza wskazuje na potencjalnÄ… okazjÄ™ do KUPNA z pewnoÅ›ciÄ… {confidence}%. RSI na poziomie {rsi:.0f} {'sugeruje wyprzedanie - dobry moment na wejÅ›cie' if rsi < 35 else 'jest w akceptowalnym zakresie'}. Cena wynosi ${price:.6f}. Rekomendujemy rozwaÅ¼enie pozycji dÅ‚ugiej z zaproponowanymi poziomami TP/SL.",
            'SHORT': f"ğŸ“Š Analiza wskazuje na potencjalnÄ… okazjÄ™ do SPRZEDAÅ»Y z pewnoÅ›ciÄ… {confidence}%. RSI na poziomie {rsi:.0f} {'sugeruje wykupienie - moÅ¼liwa korekta' if rsi > 65 else 'jest w akceptowalnym zakresie'}. Cena wynosi ${price:.6f}. Rekomendujemy rozwaÅ¼enie pozycji krÃ³tkiej z zaproponowanymi poziomami TP/SL.",
            'NEUTRAL': f"ğŸ“Š Analiza nie wskazuje wyraÅºnego kierunku (pewnoÅ›Ä‡ {confidence}%). RSI na poziomie {rsi:.0f}. Cena wynosi ${price:.6f}. Rekomendujemy poczekaÄ‡ na lepszy setup lub potwierdzenie sygnaÅ‚u."
        },
        'en': {
            'LONG': f"ğŸ“Š Analysis indicates potential BUY opportunity with {confidence}% confidence. RSI at {rsi:.0f} {'suggests oversold conditions - good entry point' if rsi < 35 else 'is within acceptable range'}. Price is ${price:.6f}. Consider long position with suggested TP/SL levels.",
            'SHORT': f"ğŸ“Š Analysis indicates potential SELL opportunity with {confidence}% confidence. RSI at {rsi:.0f} {'suggests overbought conditions - correction possible' if rsi > 65 else 'is within acceptable range'}. Price is ${price:.6f}. Consider short position with suggested TP/SL levels.",
            'NEUTRAL': f"ğŸ“Š Analysis shows no clear direction (confidence {confidence}%). RSI at {rsi:.0f}. Price is ${price:.6f}. Recommend waiting for better setup or signal confirmation."
        }
    }
    # Get template for language (fallback to English)
    lang_templates = templates.get(lang, templates['en'])
    summary = lang_templates.get(direction, lang_templates['NEUTRAL'])
    return summary
def format_analysis_report(analysis, lang='pl'):
    """Format analysis into beautiful Telegram message"""
    symbol = analysis['symbol']
    signal = analysis['signal']
    technical = analysis['technical']
    sentiment = analysis['sentiment']
    structure = analysis['structure']
    volume = analysis['volume']
    # Header
    direction_emoji = "ğŸŸ¢" if signal['direction'] == 'LONG' else "ğŸ”´" if signal['direction'] == 'SHORT' else "âšª"
    # Translations
    direction_text = {
        'LONG': {'pl': 'KUPUJ', 'en': 'BUY', 'es': 'COMPRAR', 'de': 'KAUFEN', 'fr': 'ACHETER', 'it': 'ACQUISTA', 'pt': 'COMPRAR', 'ru': 'ĞŸĞĞšĞ£ĞŸĞĞ¢Ğ¬', 'tr': 'AL', 'zh': 'ä¹°å…¥'},
        'SHORT': {'pl': 'SPRZEDAJ', 'en': 'SELL', 'es': 'VENDER', 'de': 'VERKAUFEN', 'fr': 'VENDRE', 'it': 'VENDI', 'pt': 'VENDER', 'ru': 'ĞŸĞ ĞĞ”ĞĞ¢Ğ¬', 'tr': 'SAT', 'zh': 'å–å‡º'},
        'NEUTRAL': {'pl': 'CZEKAJ', 'en': 'WAIT', 'es': 'ESPERAR', 'de': 'WARTEN', 'fr': 'ATTENDRE', 'it': 'ASPETTA', 'pt': 'AGUARDAR', 'ru': 'Ğ–Ğ”ĞĞ¢Ğ¬', 'tr': 'BEKLE', 'zh': 'ç­‰å¾…'}
    }
    direction_label = direction_text.get(signal['direction'], {}).get(lang, signal['direction'])
    # Calculate TP percentages properly
    entry = signal['entry']
    tp1_pct = ((signal['tp1'] - entry) / entry * 100) if entry > 0 else 0
    tp2_pct = ((signal['tp2'] - entry) / entry * 100) if entry > 0 else 0
    tp3_pct = ((signal['tp3'] - entry) / entry * 100) if entry > 0 else 0
    # Specjalne formatowanie dla NEUTRAL
    if signal['direction'] == 'NEUTRAL':
        reco_text = f"""ğŸ¯ REKOMENDACJE:
âš ï¸ Brak wyraÅºnego kierunku - podajemy range:
â€¢ Cena: ${entry:.6f}
â€¢ Upside target: ${signal['tp1']:.6f} ({tp1_pct:+.2f}%)
â€¢ Downside target: ${signal['tp2']:.6f} ({tp2_pct:+.2f}%)
ğŸ’¡ Rekomendacja: Poczekaj na wyraÅºniejszy sygnaÅ‚!"""
    else:
        reco_text = f"""ğŸ¯ REKOMENDACJE:
ğŸ’µ Entry: ${entry:.6f}
ğŸ¯ TP1: ${signal['tp1']:.6f} ({tp1_pct:+.2f}%)
ğŸ¯ TP2: ${signal['tp2']:.6f} ({tp2_pct:+.2f}%)
ğŸ¯ TP3: ${signal['tp3']:.6f} ({tp3_pct:+.2f}%)
ğŸ›¡ï¸ Stop Loss: ${signal['sl']:.6f}
â€¢ R/R Ratio: {signal['rr_ratio']:.2f}"""
    text = f"""{direction_emoji} {t('signal', lang)} AI - {symbol}
{'='*30}
ğŸ¯ SYGNAÅ: {direction_label} ({signal['confidence']}%)
{'='*30}
ğŸ’° CENA: ${technical['price']:.6f}
ğŸ“Š Zmiana 24h: {technical['change_24h']:+.2f}%
â± Timeframe: {analysis['timeframe']} | ğŸŒ {analysis['exchange'].upper()} | ğŸ• {datetime.now().strftime('%H:%M:%S')}
{reco_text}
"""
    # Sentiment (multilang)
    sentiment_labels = {
        'pl': {'label': 'ğŸ“ˆ SENTYMENT RYNKU:'},
        'en': {'label': 'ğŸ“ˆ MARKET SENTIMENT:'},
        'es': {'label': 'ğŸ“ˆ SENTIMIENTO:'},
        'de': {'label': 'ğŸ“ˆ MARKTSTIMMUNG:'},
        'fr': {'label': 'ğŸ“ˆ SENTIMENT:'},
        'it': {'label': 'ğŸ“ˆ SENTIMENTO:'},
        'pt': {'label': 'ğŸ“ˆ SENTIMENTO:'},
        'ru': {'label': 'ğŸ“ˆ ĞĞĞ¡Ğ¢Ğ ĞĞ•ĞĞ˜Ğ•:'},
        'tr': {'label': 'ğŸ“ˆ DUYGU:'},
        'zh': {'label': 'ğŸ“ˆ å¸‚åœºæƒ…ç»ª:'}
    }
    text += f"""{sentiment_labels.get(lang, sentiment_labels['pl'])['label']}
{sentiment['label']} ({sentiment['score']:+d}/100)
"""
    # Technical indicators (multilang)
    rsi = technical['rsi']['14']
    tech_labels = {
        'pl': 'WSKAÅ¹NIKI TECHNICZNE',
        'en': 'TECHNICAL INDICATORS',
        'es': 'INDICADORES TÃ‰CNICOS',
        'de': 'TECHNISCHE INDIKATOREN',
        'fr': 'INDICATEURS TECHNIQUES',
        'it': 'INDICATORI TECNICI',
        'pt': 'INDICADORES TÃ‰CNICOS',
        'ru': 'Ğ¢Ğ•Ğ¥ĞĞ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• Ğ˜ĞĞ”Ğ˜ĞšĞĞ¢ĞĞ Ğ«',
        'tr': 'TEKNÄ°K GÃ–STERGELER',
        'zh': 'æŠ€æœ¯æŒ‡æ ‡'
    }
    rsi_label = "ğŸ”¥ Oversold" if rsi < 20 else "ğŸ’ Overbought" if rsi > 80 else ""
    text += f"""ğŸ”§ {tech_labels.get(lang, 'WSKAÅ¹NIKI TECHNICZNE')}:
â€¢ RSI(14): {rsi:.1f} {rsi_label}
â€¢ EMA(9): ${technical['ema']['9']:.2f}
â€¢ EMA(21): ${technical['ema']['21']:.2f}
â€¢ MACD: {technical['macd']['histogram']:.2f}
"""
    # Volume (multilang)
    vol_labels = {
        'pl': {'title': 'WOLUMEN', 'ratio': 'Ratio', 'avg': 'Å›redniej', 'buy': 'Buying pressure', 'sell': 'Selling pressure'},
        'en': {'title': 'VOLUME', 'ratio': 'Ratio', 'avg': 'average', 'buy': 'Buying pressure', 'sell': 'Selling pressure'},
        'es': {'title': 'VOLUMEN', 'ratio': 'Ratio', 'avg': 'promedio', 'buy': 'PresiÃ³n compradora', 'sell': 'PresiÃ³n vendedora'},
        'de': {'title': 'VOLUMEN', 'ratio': 'VerhÃ¤ltnis', 'avg': 'Durchschnitt', 'buy': 'Kaufdruck', 'sell': 'Verkaufsdruck'},
        'ru': {'title': 'ĞĞ‘ĞªĞ•Ğœ', 'ratio': 'Ğ¡Ğ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ', 'avg': 'ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾', 'buy': 'Ğ”Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿Ğ¾Ğº', 'sell': 'Ğ”Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶'},
    }
    v = vol_labels.get(lang, vol_labels['pl'])
    text += f"""ğŸ“Š {v['title']}:
â€¢ {v['ratio']}: {volume['ratio']:.2f}x {v['avg']}
â€¢ {v['buy']}: {volume['buy_pressure']:.0f}%
â€¢ {v['sell']}: {volume['sell_pressure']:.0f}%
"""
    # Support/Resistance (multilang)
    if structure.get('support'):
        sr_labels = {
            'pl': {'title': 'WSPARCIE/OPÃ“R', 'support': 'Wsparcie', 'resistance': 'OpÃ³r'},
            'en': {'title': 'SUPPORT/RESISTANCE', 'support': 'Support', 'resistance': 'Resistance'},
            'es': {'title': 'SOPORTE/RESISTENCIA', 'support': 'Soporte', 'resistance': 'Resistencia'},
            'de': {'title': 'UNTERSTÃœTZUNG/WIDERSTAND', 'support': 'UnterstÃ¼tzung', 'resistance': 'Widerstand'},
            'ru': {'title': 'ĞŸĞĞ”Ğ”Ğ•Ğ Ğ–ĞšĞ/Ğ¡ĞĞŸĞ ĞĞ¢Ğ˜Ğ’Ğ›Ğ•ĞĞ˜Ğ•', 'support': 'ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°', 'resistance': 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ'},
        }
        sr = sr_labels.get(lang, sr_labels['pl'])
        text += f"""ğŸ“ {sr['title']}:
â€¢ {sr['support']}: ${structure['support'][0]:.4f}
â€¢ {sr['resistance']}: ${structure['resistance'][0]:.4f}
"""
    # AI Reasoning (multilang)
    reasoning_labels = {
        'pl': 'ANALIZA AI',
        'en': 'AI REASONING',
        'es': 'ANÃLISIS IA',
        'de': 'KI-ANALYSE',
        'fr': 'ANALYSE IA',
        'it': 'ANALISI IA',
        'pt': 'ANÃLISE IA',
        'ru': 'Ğ˜Ğ˜ ĞĞĞĞ›Ğ˜Ğ—',
        'tr': 'YAPAY ZEKA ANALÄ°ZÄ°',
        'zh': 'AIåˆ†æ'
    }
    # Translate reasons
    reason_translations = {
        'oversold_signal': {'pl': 'SygnaÅ‚ wyprzedania', 'en': 'Oversold signal'},
        'Low RSI': {'pl': 'Niski RSI', 'en': 'Low RSI'},
        'Strong downtrend': {'pl': 'Silny trend spadkowy', 'en': 'Strong downtrend'},
        'Selling pressure': {'pl': 'Presja sprzedaÅ¼y', 'en': 'Selling pressure'},
        'Strong uptrend': {'pl': 'Silny trend wzrostowy', 'en': 'Strong uptrend'},
        'Buying pressure': {'pl': 'Presja kupna', 'en': 'Buying pressure'},
        'Volume spike': {'pl': 'Skok wolumenu', 'en': 'Volume spike'},
        'High volatility': {'pl': 'Wysoka zmiennoÅ›Ä‡', 'en': 'High volatility'},
    }
    text += f"""ğŸ¤– {reasoning_labels.get(lang, 'ANALIZA AI')}:
"""
    for reason in signal['reasons'][:5]:
        # Try to translate
        translated = reason
        for key, trans in reason_translations.items():
            if key in reason:
                translated = trans.get(lang, reason)
                break
        text += f"â€¢ {translated}\n"
    # AI PODSUMOWANIE
    ai_summary = generate_ai_summary(signal, technical, sentiment, lang)
    text += f"""
{'='*30}
ğŸ¤– PODSUMOWANIE AI
{'='*30}
{ai_summary}
{'='*30}
{t('disclaimer', lang)}
{'='*30}
"""
    return text
logger.info("âœ… Central analyzer handlers added")
# ==========================================
# LANGUAGE SETTINGS
# ==========================================
async def language_menu(query, user_id, user):
    """Language selection menu"""
    from languages import LANGUAGES
    text = """ğŸŒ WYBIERZ JÄ˜ZYK / SELECT LANGUAGE
Wybierz swÃ³j jÄ™zyk:
Select your language:"""
    keyboard = []
    for lang_code, lang_data in LANGUAGES.items():
        keyboard.append([InlineKeyboardButton(lang_data['name'], callback_data=f'set_lang_{lang_code}')])
    keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t / Back', callback_data='settings')])
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
logger.info("âœ… Language menu added")
# ==========================================
# EXPLANATIONS MENU
# ==========================================
# ALERTS SYSTEM
# ==========================================
async def alerts_menu(query, user_id, user):
    """Main alerts menu"""
    settings = db.get_alert_settings(user_id)
    # Status emoji
    def status(enabled):
        return 'âœ…' if enabled else 'âŒ'
    text = f"""ğŸ”” SYSTEM ALERTÃ“W
ğŸ“Š Status alertÃ³w:
{status(settings['oversold_enabled'])} Oversold (RSI < 20)
{status(settings['overbought_enabled'])} Overbought (RSI > 80)
{status(settings['big_gains_enabled'])} DuÅ¼e Wzrosty (+{settings['gain_threshold']}%)
{status(settings['big_losses_enabled'])} DuÅ¼e Spadki (-{settings['loss_threshold']}%)
{status(settings['ai_signals_enabled'])} SygnaÅ‚y AI (>{settings['min_confidence']}%)
{status(settings['volume_spike_enabled'])} Volume Spike (>{settings['volume_multiplier']}x)
{status(settings['macd_cross_enabled'])} MACD Cross
{status(settings['ema_cross_enabled'])} EMA Cross
{status(settings.get('sudden_change_enabled', 0))} NagÅ‚e Zmiany ({settings.get('sudden_timeframe', '15m')}, Â±{settings.get('sudden_threshold', 5)}%)
ğŸ”” Powiadomienia: {'âœ… WÅ‚Ä…czone' if settings.get('notifications_enabled', 1) else 'âŒ WyÅ‚Ä…czone'}
âš™ï¸ Ustawienia skanera:
ğŸ“Š Zakres: TOP {settings['scan_range']}
â° CzÄ™stotliwoÅ›Ä‡: {settings['scan_frequency']}
ğŸ“ˆ Timeframe: {settings.get('alert_timeframe', '1h')}
Bot automatycznie skanuje rynek i wysyÅ‚a powiadomienia o okazjach!"""
    keyboard = [
        [InlineKeyboardButton('âš™ï¸ Ustawienia AlertÃ³w', callback_data='alerts_settings')],
        [InlineKeyboardButton('ğŸ“œ Historia (ostatnie 50)', callback_data='alerts_history')],
        [InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def alerts_settings_menu(query, user_id, user):
    """Alert settings menu"""
    settings = db.get_alert_settings(user_id)
    def btn(name, enabled):
        emoji = 'âœ…' if enabled else 'âŒ'
        return InlineKeyboardButton(f'{emoji} {name}', callback_data=f'toggle_alert_{name.lower().replace(" ", "_")}')
    text = """âš™ï¸ USTAWIENIA ALERTÃ“W
Kliknij aby wÅ‚Ä…czyÄ‡/wyÅ‚Ä…czyÄ‡:"""
    keyboard = [
        [btn('Oversold', settings['oversold_enabled'])],
        [btn('Overbought', settings['overbought_enabled'])],
        [btn('DuÅ¼e Wzrosty', settings['big_gains_enabled'])],
        [btn('DuÅ¼e Spadki', settings['big_losses_enabled'])],
        [btn('SygnaÅ‚y AI', settings['ai_signals_enabled'])],
        [btn('Volume Spike', settings['volume_spike_enabled'])],
        [btn('MACD Cross', settings['macd_cross_enabled'])],
        [btn('EMA Cross', settings['ema_cross_enabled'])],
        [InlineKeyboardButton('â”â”â”â”â”â”â”â”â”â”', callback_data='none')],
        [InlineKeyboardButton('ğŸ“Š Zakres skanowania', callback_data='set_scan_range')],
        [InlineKeyboardButton('â° CzÄ™stotliwoÅ›Ä‡', callback_data='set_scan_frequency')],
        [InlineKeyboardButton('ğŸ“ˆ Timeframe alertÃ³w', callback_data='set_alert_timeframe')],
        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - TF', callback_data='set_sudden_timeframe')],
        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - %', callback_data='set_sudden_threshold')],
        [InlineKeyboardButton('ğŸ”” Powiadomienia', callback_data='toggle_alert_notifications_enabled')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def toggle_alert(query, user_id, user, alert_type):
    """Toggle alert on/off"""
    settings = db.get_alert_settings(user_id)
    # Map button name to db field
    field_map = {
        'oversold': 'oversold_enabled',
        'overbought': 'overbought_enabled',
        'duÅ¼e_wzrosty': 'big_gains_enabled',
        'duÅ¼e_spadki': 'big_losses_enabled',
        'sygnaÅ‚y_ai': 'ai_signals_enabled',
        'volume_spike': 'volume_spike_enabled',
        'macd_cross': 'macd_cross_enabled',
        'ema_cross': 'ema_cross_enabled'
    }
    field = field_map.get(alert_type)
    if field:
        new_value = 0 if settings[field] else 1
        db.update_alert_settings(user_id, {field: new_value})
        await query.answer(f"{'âœ… WÅ‚Ä…czono' if new_value else 'âŒ WyÅ‚Ä…czono'} alert")
    await alerts_settings_menu(query, user_id, user)
async def set_scan_range(query, user_id, user, range_val=None):
    """Set scan range menu"""
    if range_val:
        db.update_alert_settings(user_id, {'scan_range': range_val})
        await query.answer(f'âœ… Ustawiono zakres: TOP {range_val}')
        await alerts_settings_menu(query, user_id, user)
        return
    text = """ğŸ“Š ZAKRES SKANOWANIA
Ile par ma byÄ‡ skanowanych?
â€¢ TOP 10 - najszybsze
â€¢ TOP 50 - balans
â€¢ TOP 100 - dokÅ‚adne
â€¢ TOP 200 - bardzo dokÅ‚adne
â€¢ ALL - wszystkie pary (wolne)"""
    keyboard = [
        [InlineKeyboardButton('TOP 10', callback_data='set_scan_range_10'), InlineKeyboardButton('TOP 50', callback_data='set_scan_range_50')],
        [InlineKeyboardButton('TOP 100', callback_data='set_scan_range_100'), InlineKeyboardButton('TOP 200', callback_data='set_scan_range_200')],
        [InlineKeyboardButton('ALL (~700)', callback_data='set_scan_range_9999')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_scan_frequency(query, user_id, user, freq=None):
    """Set scan frequency"""
    if freq:
        db.update_alert_settings(user_id, {'scan_frequency': freq})
        await query.answer(f'âœ… CzÄ™stotliwoÅ›Ä‡: {freq}')
        await alerts_settings_menu(query, user_id, user)
        return
    text = """â° CZÄ˜STOTLIWOÅšÄ† SKANOWANIA
Jak czÄ™sto bot ma sprawdzaÄ‡ rynek?
â€¢ 5m - bardzo czÄ™sto (wiÄ™cej alertÃ³w)
â€¢ 15m - balans â­
â€¢ 30m - rzadziej
â€¢ 1h - oszczÄ™dne"""
    keyboard = [
        [InlineKeyboardButton('5 minut', callback_data='set_scan_freq_5m'), InlineKeyboardButton('15 minut', callback_data='set_scan_freq_15m')],
        [InlineKeyboardButton('30 minut', callback_data='set_scan_freq_30m'), InlineKeyboardButton('1 godzina', callback_data='set_scan_freq_1h')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
# ALERTS SYSTEM
# ==========================================
async def alerts_menu(query, user_id, user):
    """Main alerts menu"""
    settings = db.get_alert_settings(user_id)
    # Status emoji
    def status(enabled):
        return 'âœ…' if enabled else 'âŒ'
    text = f"""ğŸ”” SYSTEM ALERTÃ“W
ğŸ“Š Status alertÃ³w:
{status(settings['oversold_enabled'])} Oversold (RSI < 20)
{status(settings['overbought_enabled'])} Overbought (RSI > 80)
{status(settings['big_gains_enabled'])} DuÅ¼e Wzrosty (+{settings['gain_threshold']}%)
{status(settings['big_losses_enabled'])} DuÅ¼e Spadki (-{settings['loss_threshold']}%)
{status(settings['ai_signals_enabled'])} SygnaÅ‚y AI (>{settings['min_confidence']}%)
{status(settings['volume_spike_enabled'])} Volume Spike (>{settings['volume_multiplier']}x)
{status(settings['macd_cross_enabled'])} MACD Cross
{status(settings['ema_cross_enabled'])} EMA Cross
{status(settings.get('sudden_change_enabled', 0))} NagÅ‚e Zmiany ({settings.get('sudden_timeframe', '15m')}, Â±{settings.get('sudden_threshold', 5)}%)
ğŸ”” Powiadomienia: {'âœ… WÅ‚Ä…czone' if settings.get('notifications_enabled', 1) else 'âŒ WyÅ‚Ä…czone'}
âš™ï¸ Ustawienia skanera:
ğŸ“Š Zakres: TOP {settings['scan_range']}
â° CzÄ™stotliwoÅ›Ä‡: {settings['scan_frequency']}
ğŸ“ˆ Timeframe: {settings.get('alert_timeframe', '1h')}
Bot automatycznie skanuje rynek i wysyÅ‚a powiadomienia o okazjach!"""
    keyboard = [
        [InlineKeyboardButton('âš™ï¸ Ustawienia AlertÃ³w', callback_data='alerts_settings')],
        [InlineKeyboardButton('ğŸ“œ Historia (ostatnie 50)', callback_data='alerts_history')],
        [InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def alerts_settings_menu(query, user_id, user):
    """Alert settings menu"""
    settings = db.get_alert_settings(user_id)
    def btn(name, field):
        emoji = 'âœ…' if settings[field] else 'âŒ'
        return InlineKeyboardButton(f'{emoji} {name}', callback_data=f'toggle_alert_{field}')
    text = """âš™ï¸ USTAWIENIA ALERTÃ“W
Kliknij aby wÅ‚Ä…czyÄ‡/wyÅ‚Ä…czyÄ‡:"""
    keyboard = [
        [btn('Oversold', 'oversold_enabled')],
        [btn('Overbought', 'overbought_enabled')],
        [btn('DuÅ¼e Wzrosty', 'big_gains_enabled')],
        [btn('DuÅ¼e Spadki', 'big_losses_enabled')],
        [btn('SygnaÅ‚y AI', 'ai_signals_enabled')],
        [btn('Volume Spike', 'volume_spike_enabled')],
        [btn('MACD Cross', 'macd_cross_enabled')],
        [btn('EMA Cross', 'ema_cross_enabled')],
        [btn('NagÅ‚e Zmiany', 'sudden_change_enabled')],
        [InlineKeyboardButton('â”â”â”â”â”â”â”â”â”â”', callback_data='none')],
        [InlineKeyboardButton('ğŸ“Š Zakres skanowania', callback_data='set_scan_range')],
        [InlineKeyboardButton('â° CzÄ™stotliwoÅ›Ä‡', callback_data='set_scan_frequency')],
        [InlineKeyboardButton('ğŸ“ˆ Timeframe alertÃ³w', callback_data='set_alert_timeframe')],
        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - TF', callback_data='set_sudden_timeframe')],
        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - %', callback_data='set_sudden_threshold')],
        [InlineKeyboardButton('ğŸ”” Powiadomienia', callback_data='toggle_alert_notifications_enabled')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def toggle_alert(query, user_id, user, alert_type):
    """Toggle alert on/off"""
    settings = db.get_alert_settings(user_id)
    # alert_type to juÅ¼ nazwa pola z db (oversold_enabled, etc.)
    if alert_type in settings:
        new_value = 0 if settings[alert_type] else 1
        db.update_alert_settings(user_id, {alert_type: new_value})
        await query.answer(f"{'âœ… WÅ‚Ä…czono' if new_value else 'âŒ WyÅ‚Ä…czono'} alert")
    await alerts_settings_menu(query, user_id, user)
async def set_scan_range(query, user_id, user, range_val=None):
    """Set scan range menu"""
    if range_val:
        db.update_alert_settings(user_id, {'scan_range': range_val})
        await query.answer(f'âœ… Ustawiono zakres: TOP {range_val}')
        await alerts_settings_menu(query, user_id, user)
        return
    text = """ğŸ“Š ZAKRES SKANOWANIA
Ile par ma byÄ‡ skanowanych?
â€¢ TOP 10 - najszybsze
â€¢ TOP 50 - balans
â€¢ TOP 100 - dokÅ‚adne
â€¢ TOP 200 - bardzo dokÅ‚adne
â€¢ ALL - wszystkie pary (wolne)"""
    keyboard = [
        [InlineKeyboardButton('TOP 10', callback_data='set_scan_range_10'), InlineKeyboardButton('TOP 50', callback_data='set_scan_range_50')],
        [InlineKeyboardButton('TOP 100', callback_data='set_scan_range_100'), InlineKeyboardButton('TOP 200', callback_data='set_scan_range_200')],
        [InlineKeyboardButton('ALL (~700)', callback_data='set_scan_range_9999')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_scan_frequency(query, user_id, user, freq=None):
    """Set scan frequency"""
    if freq:
        db.update_alert_settings(user_id, {'scan_frequency': freq})
        await query.answer(f'âœ… CzÄ™stotliwoÅ›Ä‡: {freq}')
        await alerts_settings_menu(query, user_id, user)
        return
    text = """â° CZÄ˜STOTLIWOÅšÄ† SKANOWANIA
Jak czÄ™sto bot ma sprawdzaÄ‡ rynek?
â€¢ 5m - bardzo czÄ™sto (wiÄ™cej alertÃ³w)
â€¢ 15m - balans â­
â€¢ 30m - rzadziej
â€¢ 1h - oszczÄ™dne"""
    keyboard = [
        [InlineKeyboardButton('5 minut', callback_data='set_scan_freq_5m'), InlineKeyboardButton('15 minut', callback_data='set_scan_freq_15m')],
        [InlineKeyboardButton('30 minut', callback_data='set_scan_freq_30m'), InlineKeyboardButton('1 godzina', callback_data='set_scan_freq_1h')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def alerts_history_menu(query, user_id, user, page=0):
    """Show alert history with pagination (10 per page)"""
    lang = get_user_language(user)
    
    try:
        # Pobierz wszystkie alerty z bazy SQLite
        all_alerts = alerts_db.get_alerts(user_id, limit=100)
        user["_temp_alerts"] = all_alerts  # Zapisz dla show_alert_detail
        
        if not all_alerts:
            keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]]
            await query.edit_message_text(
                "ğŸ“œ Historia AlertÃ³w\n\nBrak alertÃ³w w historii.",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return
        
        # Paginacja - 10 na stronÄ™
        per_page = 10
        total_pages = (len(all_alerts) + per_page - 1) // per_page
        page = max(0, min(page, total_pages - 1))
        
        start_idx = page * per_page
        end_idx = start_idx + per_page
        alerts = all_alerts[start_idx:end_idx]
        
        # TwÃ³rz kafelki
        text = f"ğŸ“œ Historia AlertÃ³w ({len(all_alerts)})\n"
        text += f"Strona {page + 1}/{total_pages}\n\n"
        
        keyboard = []
        
        # PokaÅ¼ 10 alertÃ³w na tej stronie
        for i, alert in enumerate(alerts):
            symbol = alert.get('symbol', 'N/A')
            alert_type = alert.get('alert_type', 'unknown')
            timestamp = alert.get('triggered_at', '')[:16].replace('T', ' ')
            
            # Emoji dla typu
            emoji_map = {
                'big_gain': 'ğŸ“ˆ',
                'big_loss': 'ğŸ“‰',
                'sudden_change': 'âš¡',
                'oversold': 'ğŸŸ¢',
                'overbought': 'ğŸ”´',
                'volume_spike': 'ğŸ“Š',
                'ai_signal': 'ğŸ¤–'
            }
            emoji = emoji_map.get(alert_type, 'ğŸ””')
            
            button_text = f"{emoji} {symbol} - {timestamp[5:]}"
            # Index globalny = start_idx + i
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f'alert_detail_{start_idx + i}')])
        
        # Przyciski nawigacji
        nav_buttons = []
        if page > 0:
            nav_buttons.append(InlineKeyboardButton('â¬…ï¸ Poprzednia', callback_data=f'alerts_page_{page - 1}'))
        nav_buttons.append(InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data='alerts_history'))
        if page < total_pages - 1:
            nav_buttons.append(InlineKeyboardButton('NastÄ™pna â¡ï¸', callback_data=f'alerts_page_{page + 1}'))
        
        keyboard.append(nav_buttons)
        keyboard.append([InlineKeyboardButton('â¬…ï¸ Menu', callback_data='alerts_menu')])
        
        await query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
    except Exception as e:
        logger.error(f"alerts_history_menu error: {e}", exc_info=True)
        keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]]
        await query.edit_message_text(
            f"âŒ BÅ‚Ä…d: {e}",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def analyze_from_alert(query, user_id, user, symbol, timeframe):
    """Show FULL professional analysis using format_analysis_report"""
    try:
        await query.answer()
        await query.edit_message_text('â³ AnalizujÄ™...')
        exchange = user.get('selected_exchange', 'mexc')
        # Use central_analyzer (same as AI Signals)
        from analyzer_wrapper import analyzer_with_learning as central_analyzer
        analysis = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe, language=get_user_language(user))
        if not analysis:
            # STEP 1: JeÅ›li FUTURES nie dziaÅ‚a, sprÃ³buj SPOT (ta sama para moÅ¼e byÄ‡ starsza na spot)
            if exchange == 'mexc' and ':USDT' in symbol:
                # To jest FUTURES, sprÃ³buj SPOT
                spot_symbol = symbol.replace(':USDT', '')  # BTC/USDT:USDT â†’ BTC/USDT
                logger.info(f"Futures failed, trying SPOT: {spot_symbol}")
                try:
                    analysis = await central_analyzer.analyze_pair_full(
                        exchange=exchange,
                        symbol=spot_symbol,
                        timeframe=timeframe,
                        context=context, language=get_user_language(user))
                    if analysis:
                        analysis['fallback_info'] = {
                            'original_market': 'FUTURES',
                            'used_market': 'SPOT',
                            'original_symbol': symbol,
                            'used_symbol': spot_symbol,
                            'reason': f"âš ï¸ Para {symbol} jest nowa na FUTURES lub brak danych.\nâœ… Znaleziono dane na rynku SPOT."
                        }
                        symbol = spot_symbol  # Update symbol dla display
                except Exception as e:
                    logger.error(f"SPOT fallback failed: {e}")
            # STEP 2: JeÅ›li nadal brak analizy, prÃ³buj inne timeframe'y
            if not analysis:
                # SMART FALLBACK - prÃ³buj inne timeframe'y jeÅ›li brak danych
                fallback_timeframes = ['15m', '1h', '4h', '1d']
            # UsuÅ„ aktualny timeframe z fallback
            if timeframe in fallback_timeframes:
                fallback_timeframes.remove(timeframe)
            # PrÃ³buj alternatywne timeframe'y
            for alt_tf in fallback_timeframes:
                logger.info(f"Trying fallback timeframe: {alt_tf}")
                analysis = await central_analyzer.analyze_pair_full(
                    exchange=exchange,
                    symbol=symbol,
                    timeframe=alt_tf,
                    context=context, language=get_user_language(user))
                if analysis:
                    # SUKCES - wyjaÅ›nij uÅ¼ytkownikowi
                    reason = ""
                    if timeframe in ['1m', '3m', '5m']:
                        reason = f"âš ï¸ Zbyt krÃ³tki interwaÅ‚ ({timeframe}) - para moÅ¼e byÄ‡ nowa lub brak wystarczajÄ…cych danych."
                    elif timeframe in ['1w', '1M']:
                        reason = f"âš ï¸ Zbyt dÅ‚ugi interwaÅ‚ ({timeframe}) - para moÅ¼e nie mieÄ‡ wystarczajÄ…cej historii."
                    else:
                        reason = f"âš ï¸ Brak danych dla interwaÅ‚u {timeframe} - para moÅ¼e byÄ‡ nowa lub nieaktywna."
                    # Dodaj info na poczÄ…tku analizy
                    analysis['fallback_info'] = {
                        'original_tf': timeframe,
                        'used_tf': alt_tf,
                        'reason': reason
                    }
                    timeframe = alt_tf  # Update dla dalszej czÄ™Å›ci
                    break
            if not analysis:
                await query.edit_message_text(
                    f"âŒ Nie udaÅ‚o siÄ™ przeanalizowaÄ‡ {symbol}\n\n"
                    f"PrÃ³bowano interwaÅ‚Ã³w: {timeframe}, {', '.join(fallback_timeframes)}\n\n"
                    f"MoÅ¼liwe przyczyny:\n"
                    f"â€¢ Para zbyt nowa (brak historii)\n"
                    f"â€¢ Nieaktywna para (brak wolumenu)\n"
                    f"â€¢ Problem z gieÅ‚dÄ…\n\n"
                    f"SprÃ³buj innej pary lub gieÅ‚dy.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_history')
                ]])
            )
            return
        # Format using THE SAME function as AI Signals!
        lang = get_user_language(user)
        text = format_analysis_report(analysis, lang)
        # Quick intervals at bottom
        intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '8h', '1d', '1w', '1M']
        keyboard = []
        symbol_encoded = symbol.replace('/', '_').replace(':', '_')
        row = []
        for i, tf in enumerate(intervals):
            emoji_btn = 'âœ…' if tf == timeframe else 'â±'
            row.append(InlineKeyboardButton(
                f'{emoji_btn} {tf}',
                callback_data=f'analyze_{symbol_encoded}_{tf}'
            ))
            if len(row) == 3:
                keyboard.append(row)
                row = []
        if row:
            keyboard.append(row)
        keyboard.append([
            InlineKeyboardButton('ğŸ“œ Historia', callback_data='alerts_history'),
            InlineKeyboardButton('ğŸ  Menu', callback_data='back_main')
        ])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        logger.error(f"Error in analyze_from_alert: {e}")
        import traceback
        traceback.print_exc()
        await query.edit_message_text(
            f"âŒ BÅ‚Ä…d: {e}",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_history')
            ]])
        )
async def show_alert_detail(query, user_id, user, index):
    """Show full alert details with DIRECT analysis"""
    history = user.get("_temp_alerts", alerts_db.get_alerts(user_id, limit=50))
    if index >= len(history):
        await query.answer('âŒ Nie znaleziono')
        return
    alert = history[index]
    symbol = alert['symbol']
    # Get user settings
    settings = db.get_alert_settings(user_id)
    timeframe = settings.get('alert_timeframe', '1h')
    exchange = user.get('selected_exchange', 'mexc')
    # Show loading
    await query.edit_message_text('â³ ÅadujÄ™ analizÄ™...')
    try:
        # Run analysis DIRECTLY
        from analyzer_wrapper import analyzer_with_learning as central_analyzer
        analysis = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe, language=get_user_language(user))
        if not analysis:
            raise Exception("Brak analizy")
        # Format result
        signal = analysis.get('signal', 'NEUTRAL')
        confidence = analysis.get('confidence', 0)
        rsi = analysis.get('rsi', 0)
        signal_emoji = {'LONG': 'ğŸŸ¢', 'SHORT': 'ğŸ“‰', 'NEUTRAL': 'âšª'}.get(signal, 'âšª')
        text = f"""ğŸ“Š ANALIZA: {symbol.split('/')[0]}
ğŸ”” Alert: {alert['alert_type'].upper()}
â° {alert.get('triggered_at', '')[:16]}
{signal_emoji} SygnaÅ‚: {signal}
ğŸ¯ PewnoÅ›Ä‡: {confidence}%
ğŸ“ˆ RSI: {rsi:.1f}
â± InterwaÅ‚: {timeframe}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Szybka zmiana interwaÅ‚u:"""
        # Quick interval buttons
        intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '8h', '1d', '1w', '1M']
        keyboard = []
        symbol_encoded = symbol.replace('/', '_').replace(':', '_')
        row = []
        for i, tf in enumerate(intervals):
            emoji = 'âœ…' if tf == timeframe else 'â±'
            row.append(InlineKeyboardButton(f'{emoji} {tf}', callback_data=f'analyze_{symbol_encoded}_{tf}'))
            if len(row) == 3:
                keyboard.append(row)
                row = []
        if row:
            keyboard.append(row)
        keyboard.append([
            InlineKeyboardButton('ğŸ“œ Historia', callback_data='alerts_history'),
            InlineKeyboardButton('ğŸ  Menu', callback_data='back_main')
        ])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        text = f"""âŒ BÅ‚Ä…d analizy
{alert['message']}
â° {alert.get('triggered_at', alert.get('timestamp', 'N/A'))}
BÅ‚Ä…d: {str(e)}"""
        keyboard = [[InlineKeyboardButton('ğŸ“œ PowrÃ³t', callback_data='alerts_history')]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_alert_timeframe(query, user_id, user, tf=None):
    """Set alert timeframe"""
    if tf:
        db.update_alert_settings(user_id, {'alert_timeframe': tf})
        await query.answer(f'âœ… Timeframe alertÃ³w: {tf}')
        await alerts_settings_menu(query, user_id, user)
        return
    text = """ğŸ“ˆ TIMEFRAME ALERTÃ“W
Na jakim interwale sprawdzaÄ‡ wskaÅºniki?
â€¢ 1m, 5m - bardzo krÃ³tki (scalping)
â€¢ 15m, 30m - krÃ³tki (day trading)
â€¢ 1h, 4h - Å›redni (swing) â­
â€¢ 1d, 1w - dÅ‚ugi (pozycje)
â€¢ 1M - bardzo dÅ‚ugi
WpÅ‚ywa na RSI, MACD, EMA, Volume.
Zmiana 24h zawsze na 1d."""
    keyboard = [
        [InlineKeyboardButton('1m', callback_data='set_alert_tf_1m'), 
         InlineKeyboardButton('5m', callback_data='set_alert_tf_5m'), 
         InlineKeyboardButton('15m', callback_data='set_alert_tf_15m')],
        [InlineKeyboardButton('30m', callback_data='set_alert_tf_30m'), 
         InlineKeyboardButton('1h', callback_data='set_alert_tf_1h'), 
         InlineKeyboardButton('4h', callback_data='set_alert_tf_4h')],
        [InlineKeyboardButton('8h', callback_data='set_alert_tf_8h'), 
         InlineKeyboardButton('1d', callback_data='set_alert_tf_1d'), 
         InlineKeyboardButton('1w', callback_data='set_alert_tf_1w')],
        [InlineKeyboardButton('1M', callback_data='set_alert_tf_1M')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_sudden_timeframe_menu(query, user_id, user):
    """Menu timeframe dla nagÅ‚ych zmian"""
    settings = db.get_alert_settings(user_id)
    current = settings.get('sudden_timeframe', '15m')
    text = f"""âš¡ NAGÅE ZMIANY - TIMEFRAME
Obecny: {current}
Na jakim interwale sprawdzaÄ‡ nagÅ‚e zmiany ceny?
â€¢ 5m - bardzo czuÅ‚e (duÅ¼o alertÃ³w)
â€¢ 15m - czuÅ‚e â­
â€¢ 30m - umiarkowane
â€¢ 1h - spokojne
â€¢ 4h - bardzo spokojne
PrzykÅ‚ad: wzrost o 5% w ciÄ…gu 15 minut"""
    keyboard = [
        [InlineKeyboardButton('5m', callback_data='set_sudden_tf_5m'),
         InlineKeyboardButton('15m', callback_data='set_sudden_tf_15m'),
         InlineKeyboardButton('30m', callback_data='set_sudden_tf_30m')],
        [InlineKeyboardButton('1h', callback_data='set_sudden_tf_1h'),
         InlineKeyboardButton('4h', callback_data='set_sudden_tf_4h')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_sudden_timeframe(query, user_id, user, tf):
    """Ustaw timeframe dla nagÅ‚ych zmian"""
    db.update_alert_settings(user_id, {'sudden_timeframe': tf})
    await query.answer(f'âœ… Timeframe nagÅ‚ych zmian: {tf}')
    await alerts_settings_menu(query, user_id, user)

async def alerts_sudden_settings(query, user_id, user):
    """Sudden change alert settings submenu"""
    settings = user.get('alert_settings', {})
    enabled = settings.get('sudden_change_enabled', 0)
    threshold = settings.get('sudden_threshold', 5)
    timeframe = settings.get('sudden_timeframe', '15m')
    
    status = lambda x: "âœ…" if x == 1 else "âšª"
    
    text = f"""ğŸ”” NAGÅE ZMIANY

{status(enabled)} Alert wÅ‚Ä…czony

âš™ï¸ USTAWIENIA:
â€¢ PrÃ³g: Â±{threshold}%
â€¢ InterwaÅ‚: {timeframe}

Alert gdy cena zmieni siÄ™ o Â±{threshold}% 
w ciÄ…gu {timeframe}."""

    keyboard = [
        [InlineKeyboardButton(
            f"{'âœ…' if enabled else 'âšª'} WÅ‚Ä…cz/WyÅ‚Ä…cz",
            callback_data='toggle_sudden_alert'
        )],
        [InlineKeyboardButton(f"ğŸ“Š PrÃ³g (Â±{threshold}%)", callback_data='set_sudden_threshold_menu')],
        [InlineKeyboardButton(f"â±ï¸ InterwaÅ‚ ({timeframe})", callback_data='set_sudden_timeframe_menu')],
        [InlineKeyboardButton('â¬…ï¸ Ustawienia AlertÃ³w', callback_data='alerts_settings')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def set_sudden_threshold_menu(query, user_id, user):
    """Menu for sudden change threshold - multiple options"""
    settings = user.get('alert_settings', {})
    current = settings.get('sudden_threshold', 5)
    
    text = f"""ğŸ”” PRÃ“G NAGÅYCH ZMIAN

Obecny prÃ³g: Â±{current}%

Wybierz czuÅ‚oÅ›Ä‡ alertÃ³w:

ğŸ“Š PROFILE TRADINGOWE:

â€¢ 25% (Â±5%) - Day Trading âš¡
  Bardzo czuÅ‚e, duÅ¼o alertÃ³w
  
â€¢ 50% (Â±10%) - Swing Trading ğŸ“ˆ
  Balans - rekomendowane â­
  
â€¢ 75% (Â±15%) - Position Trading ğŸ“Š
  WiÄ™ksze ruchy
  
â€¢ 90% (Â±20%) - Long-term ğŸ¯
  Tylko znaczÄ…ce zmiany
  
â€¢ 100%+ (Â±25%+) - Extreme Only ğŸ’¥
  Tylko epicki ruchy

ğŸ’¡ Im niÅ¼szy prÃ³g, tym wiÄ™cej alertÃ³w!"""

    keyboard = [
        [InlineKeyboardButton('25% (Â±5%) âš¡', callback_data='set_sudden_thresh_5'),
         InlineKeyboardButton('50% (Â±10%) â­', callback_data='set_sudden_thresh_10')],
        [InlineKeyboardButton('75% (Â±15%) ğŸ“Š', callback_data='set_sudden_thresh_15'),
         InlineKeyboardButton('90% (Â±20%) ğŸ¯', callback_data='set_sudden_thresh_20')],
        [InlineKeyboardButton('100%+ (Â±25%+) ğŸ’¥', callback_data='set_sudden_thresh_25')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_sudden_settings')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def set_sudden_threshold(query, user_id, user, threshold):
    """Ustaw prÃ³g % dla nagÅ‚ych zmian"""
    db.update_alert_settings(user_id, {'sudden_threshold': threshold})
    await query.answer(f'âœ… PrÃ³g nagÅ‚ych zmian: Â±{threshold}%')
    await alerts_settings_menu(query, user_id, user)
async def show_alert_detail(query, user_id, user, index):
    """Show full alert details with analysis button"""
    history = user.get("_temp_alerts", alerts_db.get_alerts(user_id, limit=50))
    if index >= len(history):
        await query.answer('âŒ Alert nie znaleziony')
        return
    alert = history[index]
    alert_type = alert['alert_type'].upper()
    symbol = alert['symbol']
    timestamp = alert.get('triggered_at', alert.get('timestamp', 'N/A'))
    message = alert['message']
    # Get user's timeframe setting
    settings = db.get_alert_settings(user_id)
    timeframe = settings.get('alert_timeframe', '1h')
    text = f"""ğŸ“œ SZCZEGÃ“ÅY ALERTU
{message}
â° Czas: {timestamp}
ğŸ”” Typ: {alert_type}
"""
    # Buttons
    symbol_encoded = symbol.replace('/', '_').replace(':', '_')
    keyboard = [
        [InlineKeyboardButton(
            f'ğŸ“Š Analiza {symbol.split("/")[0]} ({timeframe})',
            callback_data=f'analyze_{symbol_encoded}_{timeframe}'
        )],
        [InlineKeyboardButton('ğŸ“œ PowrÃ³t do historii', callback_data='alerts_history')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
async def explanations_menu(query, user_id, user):
    """Explanations of trading terms"""
    lang = get_user_language(user)
    text = f"""ğŸ“š WYJAÅšNIENIA TERMINÃ“W
{t('explain_rsi', lang)}
{t('explain_ema', lang)}
{t('explain_volume', lang)}
ğŸ’¡ **TP1/TP2/TP3** = Cele zysku (Take Profit) - poziomy gdzie zalecamy zamkniÄ™cie czÄ™Å›ci lub caÅ‚oÅ›ci pozycji z zyskiem
ğŸ’¡ **Stop Loss (SL)** = Poziom zamkniÄ™cia straty - punkt gdzie pozycja zostanie automatycznie zamkniÄ™ta aby ograniczyÄ‡ stratÄ™
ğŸ’¡ **R/R Ratio** = Stosunek zysku do ryzyka - ile moÅ¼esz zarobiÄ‡ w stosunku do tego ile ryzykujesz
ğŸ’¡ **Entry** = Punkt wejÅ›cia - zalecana cena otwarcia pozycji
ğŸ’¡ **Confidence %** = PewnoÅ›Ä‡ sygnaÅ‚u - im wyÅ¼szy % tym mocniejszy sygnaÅ‚ (70%+ = dobry, 80%+ = bardzo dobry)
ğŸ’¡ **LONG** = Pozycja dÅ‚uga - kupujesz oczekujÄ…c wzrostu ceny
ğŸ’¡ **SHORT** = Pozycja krÃ³tka - sprzedajesz oczekujÄ…c spadku ceny"""
    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
logger.info("âœ… Explanations menu added")
# ==========================================
# ADMIN PANEL - NEW VERSION
# ==========================================
async def admin_panel(query, user_id, user):
    """Main admin panel with statistics"""
    if user_id not in ADMIN_IDS:
        await query.answer("âŒ Brak uprawnieÅ„", show_alert=True)
        return
    
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    total_users = len(all_users)
    active_users = len(db.get_active_users(7))
    premium_users = sum(1 for u in all_users if u.get('is_premium', False))
    total_signals = sum(u.get('signals_count', 0) for u in all_users)
    
    text = f"""ğŸ‘¨â€ğŸ’¼ PANEL ADMINA

ğŸ“Š STATYSTYKI:
â€¢ UÅ¼ytkownicy: {total_users}
â€¢ Aktywni (7 dni): {active_users}
â€¢ Premium: {premium_users}
â€¢ WysÅ‚ane sygnaÅ‚y: {total_signals}

âš™ï¸ ZARZÄ„DZANIE:"""
    
    keyboard = [
        [InlineKeyboardButton('ğŸ“Š Statystyki AI', callback_data='admin_signals_stats')],
        [InlineKeyboardButton('ğŸ›ï¸ Kontrolki funkcji', callback_data='admin_features_menu')],
        [InlineKeyboardButton("ğŸ‘¥ UÅ¼ytkownicy", callback_data='admin_users_list')],
        [InlineKeyboardButton("ğŸ“¢ Broadcast", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ğŸ“Š Statystyki", callback_data='admin_stats_detailed')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


async def admin_ai_settings(query, user_id, user):
    if user_id not in ADMIN_IDS:
        await query.answer("âŒ Admin only")
        return
    import json
    try:
        with open("user_data.json") as f: cfg = json.load(f).get("config", {})
        max_w = cfg.get("max_ai_workers", 3)
    except: max_w = 3
    txt = "ğŸ¤– AI SETTINGS\\n\\nâš™ï¸ Max workers: " + str(max_w) + "\\n\\nğŸ’¡ WiÄ™cej = szybsze\\nâš ï¸ Mniej = bezpieczniej"
    kb = [[InlineKeyboardButton("1", callback_data="aiw_1"), InlineKeyboardButton("2", callback_data="aiw_2"), InlineKeyboardButton("3", callback_data="aiw_3")], [InlineKeyboardButton("4", callback_data="aiw_4"), InlineKeyboardButton("5", callback_data="aiw_5")], [InlineKeyboardButton("â¬…ï¸", callback_data="admin_panel")]]
    await query.edit_message_text(txt, reply_markup=InlineKeyboardMarkup(kb))

    if user_id not in ADMIN_IDS:
        await query.answer("âŒ Brak uprawnieÅ„", show_alert=True)
        return
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    total_users = len(all_users)
    active_users = len(db.get_active_users(7))
    premium_users = sum(1 for u in all_users if u.get('is_premium', False))
    total_signals = sum(u.get('signals_count', 0) for u in all_users)
    text = f"""ğŸ‘¨â€ğŸ’¼ PANEL ADMINA
ğŸ“Š STATYSTYKI:
â€¢ UÅ¼ytkownicy: {total_users}
â€¢ Aktywni (7 dni): {active_users}
â€¢ Premium: {premium_users}
â€¢ WysÅ‚ane sygnaÅ‚y: {total_signals}
âš™ï¸ ZARZÄ„DZANIE:"""
    keyboard = [
        [InlineKeyboardButton('ğŸ“Š Statystyki AI', callback_data='admin_signals_stats')],
        [InlineKeyboardButton('ğŸ›ï¸ Kontrolki funkcji', callback_data='admin_features_menu')],
        [InlineKeyboardButton("ğŸ‘¥ UÅ¼ytkownicy", callback_data='admin_users_list')],
        [InlineKeyboardButton("ğŸ“¢ Broadcast", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ğŸ“Š Statystyki", callback_data='admin_stats_detailed')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_users_list(query, user_id, user, page=0):
    """Show paginated list of users"""
    if user_id not in ADMIN_IDS:
        return
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    # Sort by last_active (newest first)
    all_users.sort(key=lambda u: u.get('last_active', ''), reverse=True)
    # Pagination
    per_page = 10
    total_pages = (len(all_users) + per_page - 1) // per_page
    start_idx = page * per_page
    end_idx = start_idx + per_page
    page_users = all_users[start_idx:end_idx]
    text = f"""ğŸ‘¥ UÅ»YTKOWNICY ({len(all_users)})
ğŸ“„ Strona {page + 1}/{total_pages}
Kliknij aby zarzÄ…dzaÄ‡:"""
    keyboard = []
    for u in page_users:
        uid = u['user_id']
        username = u.get('username', 'Unknown')
        is_premium = u.get('is_premium', False)
        # Premium status
        if is_premium:
            expires = u.get('subscription_expires')
            if expires:
                try:
                    from datetime import datetime
                    expires_date = datetime.fromisoformat(expires)
                    days_left = (expires_date - datetime.now()).days
                    status = f"ğŸ’ {days_left}d"
                except:
                    status = "ğŸ’"
            else:
                status = "ğŸ’"
        else:
            status = "âšª"
        # Last active
        last = u.get('last_active', '')
        if last:
            try:
                from datetime import datetime
                last_date = datetime.fromisoformat(last)
                last_str = last_date.strftime('%d.%m')
            except:
                last_str = '?'
        else:
            last_str = '?'
        button_text = f"{status} {uid[:8]}... @{username} ({last_str})"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"admin_user_{uid}")])
    # Navigation
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ Poprzednia", callback_data=f"admin_users_page_{page-1}"))
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("NastÄ™pna â¡ï¸", callback_data=f"admin_users_page_{page+1}"))
    if nav_buttons:
        keyboard.append(nav_buttons)
    keyboard.append([InlineKeyboardButton('â¬…ï¸ Panel Admina', callback_data='admin_panel')])
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_user_manage(query, user_id, target_user_id):
    """Manage specific user"""
    if user_id not in ADMIN_IDS:
        return
    target_user = db.get_user(target_user_id)
    if not target_user:
        await query.answer("âŒ UÅ¼ytkownik nie znaleziony", show_alert=True)
        return
    username = target_user.get('username', 'Unknown')
    is_premium = target_user.get('is_premium', False)
    expires = target_user.get('subscription_expires')
    signals = target_user.get('signals_count', 0)
    last_active = target_user.get('last_active', 'Nigdy')
    # Format expiry
    if is_premium and expires:
        try:
            from datetime import datetime
            exp_date = datetime.fromisoformat(expires)
            days_left = (exp_date - datetime.now()).days
            exp_str = f"{exp_date.strftime('%Y-%m-%d')} ({days_left} dni)"
        except:
            exp_str = expires
    else:
        exp_str = "Brak"
    # Format last active
    if last_active and last_active != 'Nigdy':
        try:
            from datetime import datetime
            last_date = datetime.fromisoformat(last_active)
            last_str = last_date.strftime('%Y-%m-%d %H:%M')
        except:
            last_str = last_active[:16]
    else:
        last_str = "Nigdy"
    text = f"""ğŸ‘¤ ZARZÄ„DZANIE UÅ»YTKOWNIKIEM
ğŸ†” ID: {target_user_id}
ğŸ‘¤ Username: @{username}
ğŸ’ Premium: {'Tak' if is_premium else 'Nie'}
ğŸ“… Wygasa: {exp_str}
ğŸ“Š SygnaÅ‚y: {signals}
ğŸ• Ostatnia aktywnoÅ›Ä‡: {last_str}
Wybierz akcjÄ™:"""
    keyboard = [
        [InlineKeyboardButton("ğŸ’¬ Chat z userem", callback_data=f"admin_chat_{target_user_id}")],
        [InlineKeyboardButton("â• Dodaj dni", callback_data=f"admin_add_days_{target_user_id}"),
         InlineKeyboardButton("â– Odejmij dni", callback_data=f"admin_remove_days_{target_user_id}")],
        [InlineKeyboardButton("ğŸ”’ Blokuj Premium" if is_premium else "ğŸ”“ Odblokuj Premium", 
                            callback_data=f"admin_toggle_premium_{target_user_id}")],
        [InlineKeyboardButton("ğŸ—‘ï¸ UsuÅ„ usera", callback_data=f"admin_delete_confirm_{target_user_id}")],
        [InlineKeyboardButton('â¬…ï¸ Lista uÅ¼ytkownikÃ³w', callback_data='admin_users_list')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
# ==========================================
# ADMIN HELPER FUNCTIONS
# ==========================================
async def admin_add_days_menu(query, user_id, target_uid):
    """Show menu to add days"""
    if user_id not in ADMIN_IDS:
        return
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    text = f"""â• DODAJ DNI PREMIUM
ğŸ‘¤ User: @{username}
ğŸ†” ID: {target_uid}
Wybierz ile dni dodaÄ‡:"""
    keyboard = [
        [InlineKeyboardButton("+ 3 dni", callback_data=f"admin_give_days_{target_uid}_3"),
         InlineKeyboardButton("+ 7 dni", callback_data=f"admin_give_days_{target_uid}_7")],
        [InlineKeyboardButton("+ 14 dni", callback_data=f"admin_give_days_{target_uid}_14"),
         InlineKeyboardButton("+ 30 dni", callback_data=f"admin_give_days_{target_uid}_30")],
        [InlineKeyboardButton("+ 90 dni", callback_data=f"admin_give_days_{target_uid}_90"),
         InlineKeyboardButton("+ 365 dni", callback_data=f"admin_give_days_{target_uid}_365")],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data=f'admin_user_{target_uid}')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_remove_days_menu(query, user_id, target_uid):
    """Show menu to remove days"""
    if user_id not in ADMIN_IDS:
        return
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    text = f"""â– ODEJMIJ DNI PREMIUM
ğŸ‘¤ User: @{username}
ğŸ†” ID: {target_uid}
Wybierz ile dni odjÄ…Ä‡:"""
    keyboard = [
        [InlineKeyboardButton("- 3 dni", callback_data=f"admin_take_days_{target_uid}_3"),
         InlineKeyboardButton("- 7 dni", callback_data=f"admin_take_days_{target_uid}_7")],
        [InlineKeyboardButton("- 14 dni", callback_data=f"admin_take_days_{target_uid}_14"),
         InlineKeyboardButton("- 30 dni", callback_data=f"admin_take_days_{target_uid}_30")],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data=f'admin_user_{target_uid}')]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_give_days(query, user_id, target_uid, days):
    """Add days to user subscription"""
    if user_id not in ADMIN_IDS:
        return
    from datetime import datetime, timedelta
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    # Calculate new expiry
    current_expires = target_user.get('subscription_expires')
    if current_expires:
        try:
            current_date = datetime.fromisoformat(current_expires)
            # If expired, start from now
            if current_date < datetime.now():
                new_date = datetime.now() + timedelta(days=days)
            else:
                new_date = current_date + timedelta(days=days)
        except:
            new_date = datetime.now() + timedelta(days=days)
    else:
        new_date = datetime.now() + timedelta(days=days)
    target_user['subscription_expires'] = new_date.isoformat()
    target_user['is_premium'] = True
    db.update_user(target_uid, target_user)
    await query.answer(f"âœ… Dodano {days} dni dla @{username}", show_alert=True)
    # Show updated user info
    await admin_user_manage(query, user_id, target_uid)
    logger.info(f"Admin {user_id} added {days} days to user {target_uid}")
async def admin_take_days(query, user_id, target_uid, days):
    """Remove days from user subscription"""
    if user_id not in ADMIN_IDS:
        return
    from datetime import datetime, timedelta
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    current_expires = target_user.get('subscription_expires')
    if current_expires:
        try:
            current_date = datetime.fromisoformat(current_expires)
            new_date = current_date - timedelta(days=days)
            # Check if expired
            if new_date < datetime.now():
                target_user['is_premium'] = False
                target_user['subscription_expires'] = None
            else:
                target_user['subscription_expires'] = new_date.isoformat()
        except:
            target_user['is_premium'] = False
            target_user['subscription_expires'] = None
    db.update_user(target_uid, target_user)
    await query.answer(f"âœ… OdjÄ™to {days} dni dla @{username}", show_alert=True)
    await admin_user_manage(query, user_id, target_uid)
    logger.info(f"Admin {user_id} removed {days} days from user {target_uid}")
async def admin_toggle_premium(query, user_id, target_uid):
    """Toggle premium status"""
    if user_id not in ADMIN_IDS:
        return
    from datetime import datetime, timedelta
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    is_premium = target_user.get('is_premium', False)
    if is_premium:
        # Block premium
        target_user['is_premium'] = False
        target_user['subscription_expires'] = None
        msg = f"ğŸ”’ Zablokowano Premium dla @{username}"
    else:
        # Unblock - give 30 days
        target_user['is_premium'] = True
        target_user['subscription_expires'] = (datetime.now() + timedelta(days=30)).isoformat()
        msg = f"ğŸ”“ Odblokowano Premium (30 dni) dla @{username}"
    db.update_user(target_uid, target_user)
    await query.answer(msg, show_alert=True)
    await admin_user_manage(query, user_id, target_uid)
    logger.info(f"Admin {user_id} toggled premium for user {target_uid}")
async def admin_delete_user_confirm(query, user_id, target_uid):
    """Confirm user deletion"""
    if user_id not in ADMIN_IDS:
        return
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    text = f"""âš ï¸ POTWIERDZENIE USUNIÄ˜CIA
Czy na pewno chcesz usunÄ…Ä‡ uÅ¼ytkownika?
ğŸ‘¤ @{username}
ğŸ†” {target_uid}
â— Ta akcja jest NIEODWRACALNA!"""
    keyboard = [
        [InlineKeyboardButton("ğŸ—‘ï¸ TAK, USUÅƒ", callback_data=f"admin_delete_yes_{target_uid}"),
         InlineKeyboardButton("âŒ NIE", callback_data=f"admin_user_{target_uid}")]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_delete_user(query, user_id, target_uid):
    """Delete user from database"""
    if user_id not in ADMIN_IDS:
        return
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    # Delete from database
    db.users.pop(target_uid, None)
    db.save_users()
    await query.answer(f"âœ… UsuniÄ™to @{username}", show_alert=True)
    # Return to users list
    await admin_users_list(query, user_id, user, page=0)
    logger.warning(f"Admin {user_id} DELETED user {target_uid} (@{username})")
async def admin_stats_detailed(query, user_id):
    """Detailed statistics"""
    if user_id not in ADMIN_IDS:
        return
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    from datetime import datetime, timedelta
    total = len(all_users)
    active_24h = len([u for u in all_users if u.get('last_active', '') > (datetime.now() - timedelta(hours=24)).isoformat()])
    active_7d = len(db.get_active_users(7))
    premium = sum(1 for u in all_users if u.get('is_premium', False))
    total_signals = sum(u.get('signals_count', 0) for u in all_users)
    text = f"""ğŸ“Š STATYSTYKI SZCZEGÃ“ÅOWE
ğŸ‘¥ UÅ¼ytkownicy:
â€¢ Wszyscy: {total}
â€¢ Aktywni 24h: {active_24h}
â€¢ Aktywni 7d: {active_7d}
â€¢ Premium: {premium}
ğŸ“ˆ AktywnoÅ›Ä‡:
â€¢ SygnaÅ‚y wysÅ‚ane: {total_signals}
â€¢ Åšrednio/user: {total_signals / total if total > 0 else 0:.1f}
ğŸ”” Alerty:
â€¢ Users z alertami: {len([u for u in all_users if any(v==1 for k,v in u.get('alert_settings',{}).items() if k.endswith('_enabled'))])}
ğŸ’ Premium:
â€¢ Aktywni: {premium}
â€¢ % wszystkich: {premium/total*100 if total > 0 else 0:.1f}%"""
    keyboard = [[InlineKeyboardButton('â¬…ï¸ Panel Admina', callback_data='admin_panel')]]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
async def admin_broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to broadcast message to all users"""
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("âŒ Brak uprawnieÅ„")
        return
    if not context.args:
        await update.message.reply_text(
            "UÅ¼ycie: /broadcast wiadomoÅ›Ä‡\n\n"
            "PrzykÅ‚ad: /broadcast Witam! Nowa funkcja w bocie!"
        )
        return
    message = ' '.join(context.args)
    # Get all users
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    await update.message.reply_text(f"ğŸ“¢ WysyÅ‚am do {len(all_users)} uÅ¼ytkownikÃ³w...")
    success = 0
    failed = 0
    for user_data in all_users:
        uid = user_data['user_id']
        try:
            await context.bot.send_message(
                chat_id=uid,
                text=f"ğŸ“¢ OGÅOSZENIE:\n\n{message}"
            )
            success += 1
            # Small delay to avoid rate limits
            await asyncio.sleep(0.05)
        except Exception as e:
            failed += 1
            logger.error(f"Broadcast failed for user {uid}: {e}")
    await update.message.reply_text(
        f"âœ… Broadcast zakoÅ„czony!\n\n"
        f"ğŸ“¤ WysÅ‚ano: {success}\n"
        f"âŒ BÅ‚Ä™dy: {failed}"
    )
    logger.info(f"Admin {user_id} broadcast: {success} success, {failed} failed")


async def admin_broadcast_menu(query, user_id):
    """Broadcast message menu - interactive"""
    if user_id not in ADMIN_IDS:
        return
    
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    total = len(all_users)
    
    text = f"""ğŸ“¢ BROADCAST DO WSZYSTKICH

ğŸ‘¥ Otrzyma: {total} uÅ¼ytkownikÃ³w

ğŸ’¡ INSTRUKCJA:
1. Kliknij "âœï¸ Napisz wiadomoÅ›Ä‡"
2. WyÅ›lij tekst wiadomoÅ›ci w czacie
3. PotwierdÅº wysyÅ‚kÄ™

âš ï¸ KaÅ¼dy uÅ¼ytkownik otrzyma tÄ™ wiadomoÅ›Ä‡!"""

    keyboard = [
        [InlineKeyboardButton('âœï¸ Napisz wiadomoÅ›Ä‡', callback_data='admin_broadcast_write')],
        [InlineKeyboardButton('â¬…ï¸ Panel Admina', callback_data='admin_panel')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def admin_broadcast_write(query, user_id):
    """Set state to await broadcast message"""
    if user_id not in ADMIN_IDS:
        return
    
    # Set awaiting state
    admin_user = db.get_user(user_id)
    admin_user['awaiting_broadcast'] = True
    db.update_user(user_id, admin_user)
    
    await query.edit_message_text(
        "âœï¸ NAPISZ WIADOMOÅšÄ† BROADCAST\n\n"
        "WyÅ›lij teraz wiadomoÅ›Ä‡ ktÃ³rÄ… chcesz wysÅ‚aÄ‡ do wszystkich uÅ¼ytkownikÃ³w.\n\n"
        "Aby anulowaÄ‡, wyÅ›lij /cancel"
    )

async def admin_broadcast_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE, message_text):
    """Confirm broadcast before sending"""
    user_id = update.effective_user.id
    
    if user_id not in ADMIN_IDS:
        return
    
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    total = len(all_users)
    
    # Preview
    preview = message_text[:200] + "..." if len(message_text) > 200 else message_text
    
    text = f"""ğŸ“¢ POTWIERDZENIE BROADCAST

ğŸ“¤ WysyÅ‚am do: {total} uÅ¼ytkownikÃ³w

ğŸ“ WiadomoÅ›Ä‡:
{preview}

âœ… WyÅ›lij teraz?"""

    keyboard = [
        [InlineKeyboardButton('âœ… TAK, WYÅšLIJ', callback_data=f'admin_broadcast_send')],
        [InlineKeyboardButton('âŒ Anuluj', callback_data='admin_broadcast')]
    ]
    
    # Store message temporarily
    admin_user = db.get_user(user_id)
    admin_user['pending_broadcast'] = message_text
    admin_user['awaiting_broadcast'] = False
    db.update_user(user_id, admin_user)
    
    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def admin_broadcast_send(query, user_id, context):
    """Send broadcast to all users"""
    if user_id not in ADMIN_IDS:
        return
    
    # Get stored message
    admin_user = db.get_user(user_id)
    message = admin_user.get('pending_broadcast')
    
    if not message:
        await query.answer("âŒ Brak wiadomoÅ›ci do wysÅ‚ania", show_alert=True)
        return
    
    # Clear pending
    admin_user['pending_broadcast'] = None
    db.update_user(user_id, admin_user)
    
    await query.edit_message_text("ğŸ“¢ WysyÅ‚am broadcast...\n\nProszÄ™ czekaÄ‡...")
    
    # Get all users
    all_users_dict = db.get_all_users()
    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    
    success = 0
    failed = 0
    
    for user_data in all_users:
        uid = user_data['user_id']
        
        try:
            await context.bot.send_message(
                chat_id=uid,
                text=f"ğŸ“¢ OGÅOSZENIE:\n\n{message}"
            )
            success += 1
            
            # Small delay to avoid rate limits
            await asyncio.sleep(0.05)
        except Exception as e:
            failed += 1
            logger.error(f"Broadcast failed for user {uid}: {e}")
    
    # Report
    text = f"""âœ… BROADCAST ZAKOÅƒCZONY!

ğŸ“¤ WysÅ‚ano: {success}
âŒ BÅ‚Ä™dy: {failed}

WiadomoÅ›Ä‡ zostaÅ‚a dostarczona do {success} uÅ¼ytkownikÃ³w."""

    keyboard = [[InlineKeyboardButton('â¬…ï¸ Panel Admina', callback_data='admin_panel')]]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    
    logger.info(f"Admin {user_id} broadcast: {success} success, {failed} failed")


async def admin_chat_view(query, user_id, target_uid):
    """View and manage chat with user - INTERACTIVE"""
    if user_id not in ADMIN_IDS:
        return
    
    # Check if trying to chat with self
    if target_uid == str(user_id):
        await query.edit_message_text(
            "âš ï¸ NIE MOÅ»ESZ PISAÄ† DO SIEBIE\n\n"
            "To jest chat z uÅ¼ytkownikami.\n"
            "Aby przetestowaÄ‡, uÅ¼yj innego konta.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='admin_users_list')]
            ])
        )
        return
    
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    
    # Get chat history
    chat_history = db.get_admin_chat(target_uid)
    
    if not chat_history:
        history_text = "ğŸ“­ Brak wiadomoÅ›ci"
    else:
        history_text = "ğŸ’¬ OSTATNIE WIADOMOÅšCI:\n\n"
        
        # Show last 5 messages
        for msg in chat_history[-5:]:
            from_who = "ğŸ‘¨â€ğŸ’¼ Admin" if msg['from_admin'] else f"ğŸ‘¤ @{username}"
            timestamp = msg['timestamp'][:16]  # YYYY-MM-DD HH:MM
            text = msg['message'][:80] + "..." if len(msg['message']) > 80 else msg['message']
            history_text += f"{from_who} ({timestamp}):\n{text}\n\n"
    
    text = f"""ğŸ’¬ CHAT Z UÅ»YTKOWNIKIEM

ğŸ‘¤ User: @{username}
ğŸ†” ID: {target_uid}

{history_text}"""

    keyboard = [
        [InlineKeyboardButton("âœï¸ Napisz wiadomoÅ›Ä‡", callback_data=f"admin_msg_write_{target_uid}")],
        [InlineKeyboardButton("ğŸ—‘ï¸ WyczyÅ›Ä‡ historiÄ™", callback_data=f"admin_clear_chat_{target_uid}")],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data=f'admin_user_{target_uid}')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def admin_msg_write(query, user_id, target_uid):
    """Set state to await message to specific user"""
    if user_id not in ADMIN_IDS:
        return
    
    target_user = db.get_user(target_uid)
    username = target_user.get('username', 'Unknown')
    
    # Set awaiting state
    admin_user = db.get_user(user_id)
    admin_user['awaiting_admin_message'] = target_uid
    db.update_user(user_id, admin_user)
    
    await query.edit_message_text(
        f"âœï¸ WIADOMOÅšÄ† DO @{username}\n\n"
        f"Napisz teraz wiadomoÅ›Ä‡ ktÃ³rÄ… chcesz wysÅ‚aÄ‡.\n\n"
        f"Aby anulowaÄ‡, wyÅ›lij /cancel"
    )

async def admin_msg_send(update: Update, context: ContextTypes.DEFAULT_TYPE, target_uid, message_text):
    """Send message to specific user"""
    user_id = update.effective_user.id
    
    if user_id not in ADMIN_IDS:
        return
    
    # Prevent admin from messaging themselves
    if target_uid == str(user_id):
        await update.message.reply_text(
            "âš ï¸ Nie moÅ¼esz wysÅ‚aÄ‡ wiadomoÅ›ci do siebie!\n\n"
            "JeÅ›li chcesz przetestowaÄ‡ chat, uÅ¼yj innego konta uÅ¼ytkownika."
        )
        return
    
    target_user = db.get_user(target_uid)
    if not target_user:
        await update.message.reply_text(f"âŒ User {target_uid} nie istnieje")
        return
    
    username = target_user.get('username', 'Unknown')
    
    from datetime import datetime
    
    # Save to chat history
    db.add_admin_chat_message(target_uid, from_admin=True, message=message_text, 
                               timestamp=datetime.now().isoformat())
    
    # Send to user
    try:
        await context.bot.send_message(
            chat_id=target_uid,
            text=f"ğŸ’¬ WIADOMOÅšÄ† OD ADMINA:\n\n{message_text}"
        )
        
        await update.message.reply_text(
            f"âœ… WysÅ‚ano do @{username}",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton('ğŸ’¬ PowrÃ³t do chatu', callback_data=f'admin_chat_{target_uid}')],
                [InlineKeyboardButton('ğŸ‘¤ PowrÃ³t do usera', callback_data=f'admin_user_{target_uid}')]
            ])
        )
        
        logger.info(f"Admin {user_id} sent message to user {target_uid}")
    except Exception as e:
        await update.message.reply_text(f"âŒ BÅ‚Ä…d wysyÅ‚ania: {e}")
        logger.error(f"Failed to send admin message: {e}")

async def admin_clear_chat(query, user_id, target_uid):
    """Clear chat history"""
    if user_id not in ADMIN_IDS:
        return
    
    target_user = db.get_user(target_uid)
    target_user['admin_chat_history'] = []
    db.update_user(target_uid, target_user)
    
    await query.answer("âœ… Historia czatu wyczyszczona", show_alert=True)
    await admin_chat_view(query, user_id, target_uid)


async def toggle_sudden_alert(query, user_id, user):
    """Toggle sudden change alert on/off"""
    settings = user.get('alert_settings', {})
    current = settings.get('sudden_change_enabled', 0)
    settings['sudden_change_enabled'] = 1 if current == 0 else 0
    user['alert_settings'] = settings
    
    db.update_user(user_id, user)
    
    status = "wÅ‚Ä…czony" if settings['sudden_change_enabled'] == 1 else "wyÅ‚Ä…czony"
    await query.answer(f"Alert nagÅ‚ych zmian {status}", show_alert=True)
    
    await alerts_sudden_settings(query, user_id, user)

async def set_sudden_timeframe_menu(query, user_id, user):
    """Menu for sudden change timeframe"""
    settings = user.get('alert_settings', {})
    current = settings.get('sudden_timeframe', '15m')
    
    text = f"""â±ï¸ INTERWAÅ NAGÅYCH ZMIAN

Obecny: {current}

Wybierz w jakim czasie sprawdzaÄ‡ zmiany:

â€¢ 5m - bardzo czuÅ‚e
â€¢ 15m - balans â­
â€¢ 30m - Å›rednie
â€¢ 1h - dÅ‚ugoterminowe"""

    keyboard = [
        [InlineKeyboardButton('5 min', callback_data='set_sudden_tf_5m'),
         InlineKeyboardButton('15 min â­', callback_data='set_sudden_tf_15m')],
        [InlineKeyboardButton('30 min', callback_data='set_sudden_tf_30m'),
         InlineKeyboardButton('1 godz', callback_data='set_sudden_tf_1h')],
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_sudden_settings')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


async def explanations_menu(query, user_id, user):
    """Main explanations menu"""
    text = """â„¹ï¸ WYJAÅšNIENIA

Dowiedz siÄ™ jak dziaÅ‚a BOTrader:

ğŸ“Š SygnaÅ‚y i Analiza
ğŸ“ˆ WskaÅºniki Techniczne
ğŸ¯ Alerty i Powiadomienia
âš™ï¸ Ustawienia"""

    keyboard = [
        [InlineKeyboardButton("ğŸ“Š SygnaÅ‚y i Analiza", callback_data='explain_signals')],
        [InlineKeyboardButton("ğŸ“ˆ WskaÅºniki Techniczne", callback_data='explain_indicators')],
        [InlineKeyboardButton("ğŸ¯ Alerty", callback_data='explain_alerts')],
        [InlineKeyboardButton("âš™ï¸ Ustawienia", callback_data='explain_settings')],
        [InlineKeyboardButton('â¬…ï¸ Menu GÅ‚Ã³wne', callback_data='back_main')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def explain_signals(query, user_id, user):
    """Explain signal confidence"""
    text = """ğŸ“Š SYGNAÅY I PEWNOÅšÄ†

ğŸ¯ JAK LICZONA JEST PEWNOÅšÄ†?

PewnoÅ›Ä‡ sygnaÅ‚u (0-100%) bazuje na:

1ï¸âƒ£ RSI (30%):
   â€¢ Oversold (<30) â†’ BUY
   â€¢ Overbought (>70) â†’ SELL
   â€¢ Im bardziej ekstremalne, tym wyÅ¼sza pewnoÅ›Ä‡

2ï¸âƒ£ EMA Cross (25%):
   â€¢ Szybka EMA > Wolna â†’ BUY
   â€¢ Szybka EMA < Wolna â†’ SELL
   â€¢ ÅšwieÅ¼y cross = wyÅ¼sza pewnoÅ›Ä‡

3ï¸âƒ£ MACD (25%):
   â€¢ MACD > Signal â†’ BUY
   â€¢ MACD < Signal â†’ SELL
   â€¢ Silny cross = wyÅ¼sza pewnoÅ›Ä‡

4ï¸âƒ£ Volume (20%):
   â€¢ Wysoki wolumen potwierdza sygnaÅ‚
   â€¢ Volume > Å›rednia = bonus

ğŸ“ˆ POZIOMY CONFIDENCE:

â€¢ 90-100% = Bardzo silny sygnaÅ‚ ğŸ’
â€¢ 80-89% = Silny sygnaÅ‚ â­
â€¢ 70-79% = Dobry sygnaÅ‚ âœ…
â€¢ 60-69% = Åšredni sygnaÅ‚ âš ï¸
â€¢ <60% = SÅ‚aby sygnaÅ‚ âŒ

ğŸ’¡ WSKAZÃ“WKA:
Najlepsze sygnaÅ‚y to 80%+ z potwierdzeniem
na kilku interwaÅ‚ach (15m, 1h, 4h)."""

    keyboard = [
        [InlineKeyboardButton('ğŸ“ˆ WskaÅºniki szczegÃ³Å‚owo', callback_data='explain_indicators')],
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def explain_indicators(query, user_id, user):
    """Explain technical indicators"""
    text = """ğŸ“ˆ WSKAÅ¹NIKI TECHNICZNE

ğŸ” CO ANALIZUJEMY?

ğŸ“Š RSI (Relative Strength Index):
â€¢ Zakres: 0-100
â€¢ <30 = Oversold (wyprzedanie)
â€¢ >70 = Overbought (wykupienie)
â€¢ Najlepsze sygnaÅ‚y przy ekstremach

ğŸ“‰ EMA (Exponential Moving Average):
â€¢ KrÃ³tka (9) i dÅ‚uga (21)
â€¢ Cross = zmiana trendu
â€¢ Golden Cross = silny BUY
â€¢ Death Cross = silny SELL

ğŸŒŠ MACD (Moving Average Convergence):
â€¢ Momentum indicator
â€¢ Cross linii = zmiana kierunku
â€¢ Histogram = siÅ‚a trendu

ğŸ“Š Volume (Wolumen):
â€¢ Potwierdza ruchy cenowe
â€¢ Wysoki volume = silny sygnaÅ‚
â€¢ Niski volume = sÅ‚aby ruch

ğŸ’° Bollinger Bands:
â€¢ ZmiennoÅ›Ä‡ ceny
â€¢ DotkniÄ™cie dolnej = oversold
â€¢ DotkniÄ™cie gÃ³rnej = overbought

ğŸ¯ AI Deep Analysis:
â€¢ DeepSeek AI analizuje wszystkie dane
â€¢ Wykrywa wzorce i struktury
â€¢ Dodaje kontekst rynkowy"""

    keyboard = [
        [InlineKeyboardButton('ğŸ¯ Jak uÅ¼ywaÄ‡ alertÃ³w?', callback_data='explain_alerts')],
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def explain_alerts(query, user_id, user):
    """Explain alerts system"""
    text = """ğŸ¯ SYSTEM ALERTÃ“W

ğŸ”” RODZAJE ALERTÃ“W:

1ï¸âƒ£ RSI Extremes:
   â€¢ Oversold (<30) - potencjalny BUY
   â€¢ Overbought (>70) - potencjalny SELL

2ï¸âƒ£ DuÅ¼e Wzrosty/Spadki:
   â€¢ PrÃ³g domyÅ›lny: Â±15%
   â€¢ Dostosuj w ustawieniach

3ï¸âƒ£ NagÅ‚e Zmiany:
   â€¢ Profile: 5%, 10%, 15%, 20%, 25%
   â€¢ Im niÅ¼szy, tym wiÄ™cej alertÃ³w

4ï¸âƒ£ SygnaÅ‚y AI:
   â€¢ Min. confidence: 70%
   â€¢ Najlepsze okazje

âš™ï¸ USTAWIENIA:

ğŸ“Š CzÄ™stotliwoÅ›Ä‡ skanowania:
   â€¢ 5 min - bardzo czuÅ‚e
   â€¢ 15 min - balans â­
   â€¢ 30 min - spokojniejsze

ğŸ¯ Zakres skanowania:
   â€¢ Top 50 - szybkie
   â€¢ Top 100 - balans â­
   â€¢ Top 200 - peÅ‚ne

ğŸ’¡ WSKAZÃ“WKI:

âœ… WÅ‚Ä…cz 2-3 typy alertÃ³w
âœ… Dostosuj progi do stylu tradingu
âœ… Sprawdzaj alerty na telefonie
âŒ Nie wÅ‚Ä…czaj wszystkiego naraz"""

    keyboard = [
        [InlineKeyboardButton('âš™ï¸ IdÅº do ustawieÅ„', callback_data='alerts_settings')],
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def explain_settings(query, user_id, user):
    """Explain settings"""
    text = """âš™ï¸ USTAWIENIA BOTA

ğŸŒ JÄ˜ZYK:
â€¢ Polski, English, EspaÃ±ol i wiÄ™cej
â€¢ ZmieÅ„ w: Ustawienia â†’ JÄ™zyk

â±ï¸ INTERWAÅ DOMYÅšLNY:
â€¢ Preferowany timeframe dla analiz
â€¢ Np. 15m dla day trading
â€¢ 4h dla swing trading

ğŸ“Š GIEÅDA:
â€¢ MEXC Futures (domyÅ›lnie)
â€¢ NajwiÄ™cej par do wyboru

ğŸ”” ALERTY:
â€¢ WÅ‚Ä…cz/wyÅ‚Ä…cz kaÅ¼dy typ osobno
â€¢ Dostosuj progi i czÄ™stotliwoÅ›Ä‡
â€¢ Historia ostatnich alertÃ³w

ğŸ’ PREMIUM:
â€¢ Bez limitÃ³w skanowania
â€¢ Wszystkie funkcje AI
â€¢ Priorytetowe alerty"""

    keyboard = [
        [InlineKeyboardButton('âš™ï¸ OtwÃ³rz ustawienia', callback_data='settings')],
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))



async def admin_features_menu(query, user_id, user):
    """Admin menu - kontrolki funkcji"""
    from admin_features_config import get_all_features
    
    features = get_all_features()
    
    sub_status = "ğŸŸ¢ ON" if features.get('subscription_enabled', False) else "ğŸ”´ OFF"
    ref_status = "ğŸŸ¢ ON" if features.get('referral_enabled', True) else "ğŸ”´ OFF"
    
    text = f"""ğŸ›ï¸ KONTROLKI FUNKCJI

ZarzÄ…dzaj widocznoÅ›ciÄ… funkcji dla uÅ¼ytkownikÃ³w:

ğŸ’³ SUBSKRYPCJA: {sub_status}
ğŸ POLECENIA: {ref_status}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Gdy funkcja jest OFF:
â€¢ Przycisk znika z menu uÅ¼ytkownikÃ³w
â€¢ Funkcja niedostÄ™pna

âœ… Gdy funkcja jest ON:
â€¢ Przycisk widoczny w menu
â€¢ Funkcja dostÄ™pna dla wszystkich"""

    keyboard = [
        [InlineKeyboardButton(
            f"ğŸ’³ Subskrypcja: {'âœ…' if features.get('subscription_enabled', False) else 'âŒ'}", 
            callback_data='admin_toggle_subscription'
        )],
        [InlineKeyboardButton(
            f"ğŸ Polecenia: {'âœ…' if features.get('referral_enabled', True) else 'âŒ'}", 
            callback_data='admin_toggle_referral'
        )],
        [InlineKeyboardButton('â¬…ï¸ Admin Panel', callback_data='admin_panel')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


async def admin_toggle_feature(query, user_id, feature_name):
    """Toggle feature on/off"""
    from admin_features_config import toggle_feature
    
    new_status = toggle_feature(feature_name)
    
    feature_names = {
        'subscription_enabled': 'ğŸ’³ Subskrypcja',
        'referral_enabled': 'ğŸ Polecenia'
    }
    
    status = "âœ… WÅÄ„CZONA" if new_status else "âŒ WYÅÄ„CZONA"
    
    await query.answer(
        f"{feature_names.get(feature_name)}: {status}", 
        show_alert=True
    )
    
    user = db.get_user(user_id)
    await admin_features_menu(query, user_id, user)



async def admin_signals_stats(query, user_id, user):
    """Admin panel - statystyki sygnaÅ‚Ã³w AI"""
    if user_id not in ADMIN_IDS:
        await query.answer("âŒ Brak uprawnieÅ„", show_alert=True)
        return
    
    from ai_signals_tracker import tracker
    
    # Pobierz statystyki
    stats_24h = tracker.get_accuracy_stats('24h')
    stats_48h = tracker.get_accuracy_stats('48h')
    stats_7d = tracker.get_accuracy_stats('7d')
    
    total_signals = len(tracker.signals_db)
    

    # Oblicz statystyki bezpoÅ›rednio z ai_signals_history.json
    try:
        with open('ai_signals_history.json', 'r') as f:
            history = json.load(f)
        
        all_signals = list(history.values())
        
        # 24h
        verified_24h = [s for s in all_signals if s.get('checked_24h')]
        success_24h = [s for s in verified_24h if s.get('result_24h') == 'success']
        accuracy_24h = (len(success_24h) / len(verified_24h) * 100) if verified_24h else 0
        
        # 48h
        verified_48h = [s for s in all_signals if s.get('checked_48h')]
        success_48h = [s for s in verified_48h if s.get('result_48h') == 'success']
        accuracy_48h = (len(success_48h) / len(verified_48h) * 100) if verified_48h else 0
        
        # 7d
        verified_7d = [s for s in all_signals if s.get('checked_7d')]
        success_7d = [s for s in verified_7d if s.get('result_7d') == 'success']
        accuracy_7d = (len(success_7d) / len(verified_7d) * 100) if verified_7d else 0

        # 1M
        verified_1M = [s for s in all_signals if s.get("checked_1M")]
        success_1M = [s for s in verified_1M if s.get("result_1M") == "success"]
        accuracy_1M = (len(success_1M) / len(verified_1M) * 100) if verified_1M else 0

        # 6M
        verified_6M = [s for s in all_signals if s.get("checked_6M")]
        success_6M = [s for s in verified_6M if s.get("result_6M") == "success"]
        accuracy_6M = (len(success_6M) / len(verified_6M) * 100) if verified_6M else 0

        # 1Y
        verified_1Y = [s for s in all_signals if s.get("checked_1Y")]
        success_1Y = [s for s in verified_1Y if s.get("result_1Y") == "success"]
        accuracy_1Y = (len(success_1Y) / len(verified_1Y) * 100) if verified_1Y else 0
    except Exception as e:
        print(f"Error calculating stats: {e}")
        verified_24h = verified_48h = verified_7d = []
        success_24h = success_48h = success_7d = []
        accuracy_24h = accuracy_48h = accuracy_7d = 0
    
    text = f"""ğŸ“Š STATYSTYKI SYGNAÅÃ“W AI

ğŸ“ˆ OGÃ“LNE:
â€¢ Wszystkie sygnaÅ‚y: {total_signals}

â° TRAFNOÅšÄ†:
    â€¢ 24h: {accuracy_24h:.0f}% ({len(success_24h)}/{len(verified_24h)})
    â€¢ 48h: {accuracy_48h:.0f}% ({len(success_48h)}/{len(verified_48h)})
    â€¢ 7d:  {accuracy_7d:.0f}% ({len(success_7d)}/{len(verified_7d)})
        â€¢ 1M:  {accuracy_1M:.0f}% ({len(success_1M)}/{len(verified_1M)})
        â€¢ 6M:  {accuracy_6M:.0f}% ({len(success_6M)}/{len(verified_6M)})
        â€¢ 1Y:  {accuracy_1Y:.0f}% ({len(success_1Y)}/{len(verified_1Y)})
"""
    
    # Dodaj breakdown po typach sygnaÅ‚Ã³w
    if stats_24h.get('by_signal_type'):
        text += "\nğŸ“Š TRAFNOÅšÄ† WG TYPU (24h):\n"
        for sig_type, data in stats_24h['by_signal_type'].items():
            text += f"â€¢ {sig_type}: {data['accuracy_pct']}% ({data['correct']}/{data['total']})\n"
    
    text += "\nğŸ’¡ Dane aktualizowane co godzinÄ™ przez SignalChecker"
    
    keyboard = [
        [InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data='admin_signals_stats')],
        [InlineKeyboardButton('ğŸ“¥ Export JSON', callback_data='admin_export_signals')],
        [InlineKeyboardButton('â¬…ï¸ Admin Panel', callback_data='admin_panel')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


async def admin_export_signals(query, user_id, user):
    """Export signal data to JSON"""
    if user_id not in ADMIN_IDS:
        await query.answer("âŒ Brak uprawnieÅ„", show_alert=True)
        return
    
    from ai_signals_tracker import tracker
    import os
    
    # Export
    filename = tracker.export_for_analysis(f'signals_export_{int(time.time())}.json')
    
    # SprawdÅº rozmiar
    size_mb = os.path.getsize(filename) / (1024 * 1024)
    
    text = f"""âœ… EXPORT GOTOWY!

ğŸ“ Plik: {filename}
ğŸ’¾ Rozmiar: {size_mb:.2f} MB

Plik zawiera:
â€¢ Wszystkie sygnaÅ‚y
â€¢ Wyniki weryfikacji
â€¢ Statystyki trafnoÅ›ci
â€¢ Dane techniczne

MoÅ¼esz pobraÄ‡ plik z serwera VPS."""
    
    keyboard = [
        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='admin_signals_stats')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


# ============================================================================
# PORTFOLIO TRACKER - Complete Implementation
# ============================================================================

from portfolio_manager import portfolio

async def portfolio_main(query, user_id, user):
    """Portfolio main menu"""
    stats = portfolio.get_stats(user_id)
    open_positions = portfolio.get_open_positions(user_id)
    
    text = f"""ğŸ’¼ PORTFOLIO TRACKER

ğŸ“Š STATYSTYKI:
â€¢ Open positions: {len(open_positions)}
â€¢ Total trades: {stats['total_trades']}
â€¢ Win rate: {stats['win_rate']:.1f}%
â€¢ Total PnL: ${stats['total_realized_pnl']:.2f}

ğŸ† BEST/WORST:
â€¢ Best trade: ${stats['best_trade']:.2f}
â€¢ Worst trade: ${stats['worst_trade']:.2f}
"""
    
    keyboard = [
        [InlineKeyboardButton('ğŸ“Š Dashboard', callback_data='portfolio_dashboard')],
        [InlineKeyboardButton('â• Add Position', callback_data='portfolio_add_start')],
        [InlineKeyboardButton('ğŸ“‹ Open Positions', callback_data='portfolio_open')],
        [InlineKeyboardButton('â¬…ï¸ Main Menu', callback_data='back_main')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def portfolio_dashboard(query, user_id, user):
    """Portfolio dashboard with live PnL"""
    from exchanges import exchange_api
    
    open_positions = portfolio.get_open_positions(user_id)
    
    if not open_positions:
        text = "ğŸ“Š DASHBOARD\n\nâŒ No open positions\n\nAdd your first position to start tracking!"
        keyboard = [
            [InlineKeyboardButton('â• Add Position', callback_data='portfolio_add_start')],
            [InlineKeyboardButton('â¬…ï¸ Back', callback_data='portfolio_main')]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    total_pnl_usd = 0
    total_size = 0
    position_texts = []
    
    for pos in open_positions[:10]:
        try:
            ticker = await exchange_api.get_ticker(pos['symbol'], 'mexc')
            if ticker and 'last' in ticker:
                current_price = ticker['last']
                pnl_data = portfolio.calculate_pnl(pos, current_price)
                
                total_pnl_usd += pnl_data['pnl_usd']
                total_size += pos['size']
                
                emoji = 'ğŸš€' if pos['type'] == 'LONG' else 'ğŸ“‰'
                status_emoji = 'ğŸŸ¢' if pnl_data['pnl_usd'] > 0 else 'ğŸ”´' if pnl_data['pnl_usd'] < 0 else 'âšª'
                
                pos_text = f"{emoji} {pos['symbol']}\n"
                pos_text += f"  {status_emoji} PnL: ${pnl_data['pnl_usd']:.2f} ({pnl_data['pnl_pct']:.2f}%)\n"
                pos_text += f"  Entry: ${pos['entry']:.4f} â†’ Now: ${current_price:.4f}"
                
                position_texts.append(pos_text)
        except Exception as e:
            logger.error(f"Error calculating PnL for {pos['symbol']}: {e}")
    
    total_pnl_pct = (total_pnl_usd / total_size * 100) if total_size > 0 else 0
    pnl_emoji = 'ğŸŸ¢' if total_pnl_usd > 0 else 'ğŸ”´' if total_pnl_usd < 0 else 'âšª'
    
    text = f"""ğŸ“Š PORTFOLIO DASHBOARD

{pnl_emoji} TOTAL PnL: ${total_pnl_usd:.2f} ({total_pnl_pct:.2f}%)
ğŸ’° Total Size: ${total_size:.2f}
ğŸ“ˆ Positions: {len(open_positions)}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    
    text += "\n\n".join(position_texts)
    
    if len(open_positions) > 10:
        text += f"\n\n... and {len(open_positions) - 10} more positions"
    
    keyboard = [
        [InlineKeyboardButton('ğŸ”„ Refresh', callback_data='portfolio_dashboard')],
        [InlineKeyboardButton('ğŸ“‹ All Positions', callback_data='portfolio_open')],
        [InlineKeyboardButton('â¬…ï¸ Back', callback_data='portfolio_main')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def portfolio_open(query, user_id, user):
    """List open positions"""
    open_positions = portfolio.get_open_positions(user_id)
    
    if not open_positions:
        text = "ğŸ“‹ OPEN POSITIONS\n\nâŒ No open positions"
        keyboard = [[InlineKeyboardButton('â¬…ï¸ Back', callback_data='portfolio_main')]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    text = f"ğŸ“‹ OPEN POSITIONS ({len(open_positions)})\n\nSelect position to view details:"
    
    keyboard = []
    for pos in open_positions[:20]:
        emoji = 'ğŸš€' if pos['type'] == 'LONG' else 'ğŸ“‰'
        label = f"{emoji} {pos['symbol']} (${pos['size']:.0f})"
        keyboard.append([InlineKeyboardButton(label, callback_data=f"portfolio_view_{pos['id']}")])
    
    keyboard.append([InlineKeyboardButton('â¬…ï¸ Back', callback_data='portfolio_main')])
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def portfolio_view(query, user_id, user, pos_id):
    """View position details"""
    from exchanges import exchange_api
    
    position = portfolio.get_position(user_id, pos_id)
    
    if not position:
        await query.answer("âŒ Position not found", show_alert=True)
        return
    
    try:
        ticker = await exchange_api.get_ticker(position['symbol'], 'mexc')
        current_price = ticker['last'] if ticker else position['entry']
    except:
        current_price = position['entry']
    
    pnl_data = portfolio.calculate_pnl(position, current_price)
    
    emoji = 'ğŸš€' if position['type'] == 'LONG' else 'ğŸ“‰'
    status_emoji = 'ğŸŸ¢' if pnl_data['pnl_usd'] > 0 else 'ğŸ”´' if pnl_data['pnl_usd'] < 0 else 'âšª'
    
    text = f"""{emoji} {position['symbol']} - {position['type']}

{status_emoji} PnL: ${pnl_data['pnl_usd']:.2f} ({pnl_data['pnl_pct']:.2f}%)

ğŸ’° POSITION:
â€¢ Size: ${position['size']:.2f}
â€¢ Leverage: {position['leverage']}x
â€¢ Entry: ${position['entry']:.6f}
â€¢ Current: ${current_price:.6f}

ğŸ¯ TARGETS:
"""
    
    if position.get('tp1'):
        dist1 = ((position['tp1'] - current_price) / current_price * 100)
        text += f"â€¢ TP1: ${position['tp1']:.6f} ({dist1:+.2f}%)\n"
    if position.get('tp2'):
        dist2 = ((position['tp2'] - current_price) / current_price * 100)
        text += f"â€¢ TP2: ${position['tp2']:.6f} ({dist2:+.2f}%)\n"
    if position.get('tp3'):
        dist3 = ((position['tp3'] - current_price) / current_price * 100)
        text += f"â€¢ TP3: ${position['tp3']:.6f} ({dist3:+.2f}%)\n"
    
    if position.get('sl'):
        dist_sl = ((position['sl'] - current_price) / current_price * 100)
        text += f"\nğŸ›¡ï¸ Stop Loss: ${position['sl']:.6f} ({dist_sl:+.2f}%)"
    
    if position.get('liquidation', 0) > 0:
        dist_liq = ((position['liquidation'] - current_price) / current_price * 100)
        text += f"\nâš ï¸ Liquidation: ${position['liquidation']:.6f} ({dist_liq:+.2f}%)"
    
    text += f"\n\nğŸ“… Opened: {position['opened_at'][:16]}"
    
    keyboard = [
        [InlineKeyboardButton('ğŸ”„ Refresh', callback_data=f"portfolio_view_{pos_id}")],
        [InlineKeyboardButton('ğŸ”’ Close Position', callback_data=f"portfolio_close_confirm_{pos_id}")],
        [InlineKeyboardButton('â¬…ï¸ Back', callback_data='portfolio_open')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def portfolio_close_confirm(query, user_id, user, pos_id):
    """Confirm closing position"""
    position = portfolio.get_position(user_id, pos_id)
    
    if not position:
        await query.answer("âŒ Position not found", show_alert=True)
        return
    
    text = f"""ğŸ”’ CLOSE POSITION?

{position['symbol']} - {position['type']}
Size: ${position['size']:.2f}

This will close the position at current market price.

Are you sure?"""
    
    keyboard = [
        [InlineKeyboardButton('âœ… Yes, Close', callback_data=f"portfolio_close_yes_{pos_id}")],
        [InlineKeyboardButton('âŒ Cancel', callback_data=f"portfolio_view_{pos_id}")]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def portfolio_close_execute(query, user_id, user, pos_id):
    """Execute position close"""
    from exchanges import exchange_api
    
    position = portfolio.get_position(user_id, pos_id)
    
    if not position:
        await query.answer("âŒ Position not found", show_alert=True)
        return
    
    try:
        ticker = await exchange_api.get_ticker(position['symbol'], 'mexc')
        close_price = ticker['last'] if ticker else position['entry']
    except:
        close_price = position['entry']
    
    result = portfolio.close_position(user_id, pos_id, close_price, 'manual')
    
    if result['success']:
        pnl_emoji = 'ğŸŸ¢' if result['pnl_usd'] > 0 else 'ğŸ”´'
        text = f"""{pnl_emoji} POSITION CLOSED!

{position['symbol']} - {position['type']}

ğŸ’° Final PnL: ${result['pnl_usd']:.2f} ({result['pnl_pct']:.2f}%)

Entry: ${position['entry']:.6f}
Exit: ${close_price:.6f}
Size: ${position['size']:.2f}
Leverage: {position['leverage']}x"""
        
        keyboard = [
            [InlineKeyboardButton('ğŸ“Š Dashboard', callback_data='portfolio_dashboard')],
            [InlineKeyboardButton('â¬…ï¸ Main Menu', callback_data='portfolio_main')]
        ]
        
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await query.answer(f"âŒ Error: {result.get('error')}", show_alert=True)

async def portfolio_add_start(query, user_id, user):
    """Start adding position"""
    text = """â• ADD NEW POSITION

ğŸ“ Step 1/6: Enter symbol

Just type the ticker (auto-completes):
   âœ… BTC â†’ BTC/USDT:USDT
   âœ… ETH â†’ ETH/USDT:USDT
   âœ… Or full: BTC/USDT:USDT

Type symbol or /cancel"""
    
    user['state'] = 'portfolio_add_symbol'
    
    keyboard = [[InlineKeyboardButton('âŒ Cancel', callback_data='portfolio_main')]]
    # Set Portfolio state
    user['state'] = 'portfolio_add_symbol'
    # State saved automatically (user is reference)
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


# Portfolio Message Handlers (for add position flow)

async def handle_portfolio_add_symbol(message, user_id, user):
    """Handle symbol input with auto-complete"""
    symbol = message.text.upper().strip()
    
    if ':' not in symbol or '/' not in symbol:
        await message.reply_text("âŒ UÅ¼yj peÅ‚nego symbolu: BTC/USDT:USDT")
        return
        await message.reply_text("âŒ Invalid format. Use: BTC or BTC/USDT:USDT")
        return
    
    if 'portfolio_new' not in user:
        user['portfolio_new'] = {}
    
    user['portfolio_new']['symbol'] = symbol
    user['state'] = 'portfolio_add_type'
    
    text = f"""â• ADD POSITION: {symbol}

ğŸ“ Step 2/6: Position type"""
    
    keyboard = [
        [InlineKeyboardButton('ğŸš€ LONG', callback_data='portfolio_type_LONG')],
        [InlineKeyboardButton('ğŸ“‰ SHORT', callback_data='portfolio_type_SHORT')],
        [InlineKeyboardButton('âŒ Cancel', callback_data='portfolio_main')]
    ]
    
    await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_portfolio_add_entry(message, user_id, user):
    """Handle entry price input"""
    try:
        entry = float(message.text.strip())
        user['portfolio_new']['entry'] = entry
        user['state'] = 'portfolio_add_size'
        
        text = f"""â• ADD POSITION: {user['portfolio_new']['symbol']}
ğŸ¯ Entry: ${entry:.6f}

ğŸ“ Step 4/6: Position size

Enter size in USDT (e.g., 1000)"""
        
        await message.reply_text(text)
        
    except ValueError:
        await message.reply_text("âŒ Invalid price. Enter number (e.g., 95000)")

async def handle_portfolio_add_size(message, user_id, user):
    """Handle position size input"""
    try:
        size = float(message.text.strip())
        user['portfolio_new']['size'] = size
        user['state'] = 'portfolio_add_leverage'
        
        text = f"""â• ADD POSITION: {user['portfolio_new']['symbol']}
ğŸ’° Size: ${size:.2f}

ğŸ“ Step 5/6: Leverage"""
        
        keyboard = [
            [InlineKeyboardButton('1x', callback_data='portfolio_lev_1'),
             InlineKeyboardButton('5x', callback_data='portfolio_lev_5'),
             InlineKeyboardButton('10x', callback_data='portfolio_lev_10')],
            [InlineKeyboardButton('20x', callback_data='portfolio_lev_20'),
             InlineKeyboardButton('50x', callback_data='portfolio_lev_50'),
             InlineKeyboardButton('100x', callback_data='portfolio_lev_100')],
            [InlineKeyboardButton('âŒ Cancel', callback_data='portfolio_main')]
        ]
        
        await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        
    except ValueError:
        await message.reply_text("âŒ Invalid size. Enter number (e.g., 1000)")

async def handle_portfolio_add_targets(message, user_id, user):
    """Handle targets input"""

    # Portfolio state check - HIGHEST PRIORITY
    state = user.get('state') if 'user' in locals() else None
    if state and state.startswith('portfolio_'):
        if state == 'portfolio_add_symbol':
            await handle_portfolio_add_symbol(message, user_id, user)
            return
        elif state == 'portfolio_add_entry':
            await handle_portfolio_add_entry(message, user_id, user)
            return
        elif state == 'portfolio_add_size':
            await handle_portfolio_add_size(message, user_id, user)
            return
        elif state == 'portfolio_add_targets':
            # Recursion removed
            return


    text = message.text.strip().lower()
    
    if text == 'skip':
        await finish_portfolio_add(message, user_id, user, None, None, None, None)
        return
    
    try:
        parts = text.split()
        
        # Flexible parsing:
        # 1 number = SL only
        # 2 numbers = TP1 SL
        # 3 numbers = TP1 TP2 SL
        # 4 numbers = TP1 TP2 TP3 SL
        
        if len(parts) == 1:
            tp1, tp2, tp3 = None, None, None
            sl = float(parts[0])
        elif len(parts) == 2:
            tp1 = float(parts[0])
            tp2, tp3 = None, None
            sl = float(parts[1])
        elif len(parts) == 3:
            tp1 = float(parts[0])
            tp2 = float(parts[1])
            tp3 = None
            sl = float(parts[2])
        elif len(parts) >= 4:
            tp1 = float(parts[0])
            tp2 = float(parts[1])
            tp3 = float(parts[2])
            sl = float(parts[3])
        else:
            tp1 = tp2 = tp3 = sl = None
        
        await finish_portfolio_add(message, user_id, user, tp1, tp2, tp3, sl)
        
    except (ValueError, IndexError):
        await message.reply_text("âŒ Invalid format.\nExamples:\nâ€¢ 94000 (SL only)\nâ€¢ 96000 94000 (TP1 SL)\nâ€¢ 96000 97000 94000 (TP1 TP2 SL)\nâ€¢ 96000 97000 98000 94000 (TP1 TP2 TP3 SL)\nOr type 'skip'")

async def handle_portfolio_type(query, user_id, user, pos_type):
    """Handle position type selection"""
    user['portfolio_new']['type'] = pos_type
    user['state'] = 'portfolio_add_entry'
    
    emoji = 'ğŸš€' if pos_type == 'LONG' else 'ğŸ“‰'
    
    text = f"""â• ADD POSITION: {user['portfolio_new']['symbol']}
{emoji} Type: {pos_type}

ğŸ“ Step 3/6: Entry price

Enter the entry price (e.g., 95000)"""
    
    await query.edit_message_text(text)

async def handle_portfolio_leverage(query, user_id, user, leverage):
    """Handle leverage selection"""
    user['portfolio_new']['leverage'] = leverage
    user['state'] = 'portfolio_add_targets'
    
    text = f"""â• ADD POSITION: {user['portfolio_new']['symbol']}
âš¡ Leverage: {leverage}x

ğŸ“ Step 6/6: Targets (Optional)

Enter TP and SL prices or skip:
Format: TP1 TP2 TP3 SL

Example: 96000 97000 98000 94000

Or type 'skip' to finish without targets"""
    
    keyboard = [
        [InlineKeyboardButton('â­ï¸ Skip', callback_data='portfolio_skip_targets')],
        [InlineKeyboardButton('âŒ Cancel', callback_data='portfolio_main')]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def finish_portfolio_add(message_or_query, user_id, user, tp1, tp2, tp3, sl):
    """Finish adding position"""
    new_pos = user.get('portfolio_new', {})
    
    pos_id = portfolio.add_position(
        user_id=user_id,
        symbol=new_pos['symbol'],
        position_type=new_pos['type'],
        entry=new_pos['entry'],
        size=new_pos['size'],
        leverage=new_pos['leverage'],
        tp1=tp1,
        tp2=tp2,
        tp3=tp3,
        sl=sl
    )
    
    emoji = 'ğŸš€' if new_pos['type'] == 'LONG' else 'ğŸ“‰'
    
    text = f"""âœ… POSITION ADDED!

{emoji} {new_pos['symbol']} - {new_pos['type']}
ğŸ’° Size: ${new_pos['size']:.2f}
âš¡ Leverage: {new_pos['leverage']}x
ğŸ¯ Entry: ${new_pos['entry']:.6f}
"""
    
    if tp1:
        text += f"\nğŸ¯ TP1: ${tp1:.6f}"
    if tp2:
        text += f"\nğŸ¯ TP2: ${tp2:.6f}"
    if tp3:
        text += f"\nğŸ¯ TP3: ${tp3:.6f}"
    if sl:
        text += f"\nğŸ›¡ï¸ SL: ${sl:.6f}"
    
    text += f"\n\nPosition ID: {pos_id}"
    
    keyboard = [
        [InlineKeyboardButton('ğŸ“Š View Dashboard', callback_data='portfolio_dashboard')],
        [InlineKeyboardButton('â• Add Another', callback_data='portfolio_add_start')],
        [InlineKeyboardButton('â¬…ï¸ Main Menu', callback_data='portfolio_main')]
    ]
    
    user['state'] = None
    user['portfolio_new'] = {}
    
    if hasattr(message_or_query, 'edit_message_text'):
        await message_or_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await message_or_query.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


# DEBUG Portfolio
import logging
portfolio_logger = logging.getLogger('portfolio_debug')
portfolio_logger.setLevel(logging.DEBUG)

# Wrap handle_portfolio_add_symbol with logging
_original_handle_portfolio_add_symbol = handle_portfolio_add_symbol

async def handle_portfolio_add_symbol_debug(message, user_id, user):
    portfolio_logger.info(f"ğŸ” PORTFOLIO: User {user_id} sent: {message.text}")
    portfolio_logger.info(f"ğŸ” PORTFOLIO: User state: {user.get('state')}")
    await _original_handle_portfolio_add_symbol(message, user_id, user)

# Replace
handle_portfolio_add_symbol = handle_portfolio_add_symbol_debug


# ============================================================================
# CHART DISPLAY - Interactive Charts for Signals
# ============================================================================

import pandas as pd
from chart_generator import chart_gen

async def show_signal_chart(query, signal_id):
    """Generate and send chart for AI signal"""
    try:
        # Get signal data from ai_signals_history.json
        import json
        
        with open('ai_signals_history.json', 'r') as f:
            signals = json.load(f)
        
        if signal_id not in signals:
            await query.answer("âŒ Signal not found", show_alert=True)
            return
        
        signal = signals[signal_id]
        
        # Fetch OHLCV data
        from exchanges import exchange_api
        
        symbol = signal['symbol']
        tf = signal.get('timeframe', '1h')
        
        await query.answer("ğŸ“Š Generating chart...", show_alert=False)
        
        # Get historical data
        ohlcv = await exchange_api.get_ohlcv(symbol, tf, limit=200)
        
        if not ohlcv or len(ohlcv) == 0:
            await query.answer("âŒ No data available", show_alert=True)
            return
        
        # Convert to DataFrame
        df = pd.DataFrame(
            ohlcv,
            columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']
        )
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        
        # Get trade parameters
        entry_price = signal.get('price', df['close'].iloc[-1])
        direction = signal.get('direction', 'LONG')
        
        # Calculate TP/SL (if not in signal)
        tp_levels = []
        if 'targets' in signal and signal['targets']:
            tp_levels = signal['targets'][:3]  # Max 3 TPs
        else:
            # Auto-calculate based on direction
            if direction == 'LONG':
                tp_levels = [
                    entry_price * 1.02,  # +2%
                    entry_price * 1.04,  # +4%
                    entry_price * 1.06,  # +6%
                ]
            else:
                tp_levels = [
                    entry_price * 0.98,  # -2%
                    entry_price * 0.96,  # -4%
                    entry_price * 0.94,  # -6%
                ]
        
        sl_price = signal.get('stop_loss')
        if not sl_price:
            # Auto-calculate SL
            sl_price = entry_price * 0.98 if direction == 'LONG' else entry_price * 1.02
        
        # Generate chart
        img_bytes = await chart_gen.generate_signal_chart(
            symbol=symbol,
            timeframe=tf,
            ohlcv_data=df,
            entry_price=entry_price,
            position_type=direction,
            tp_levels=tp_levels,
            sl_price=sl_price,
        )
        
        # Send chart
        caption = f"ğŸ“Š {symbol} {tf} - {direction}\n"
        caption += f"ğŸ¯ Entry: ${entry_price:,.2f}\n"
        if tp_levels:
            caption += f"âœ… TP: ${tp_levels[0]:,.2f}"
            if len(tp_levels) > 1:
                caption += f" / ${tp_levels[1]:,.2f}"
            if len(tp_levels) > 2:
                caption += f" / ${tp_levels[2]:,.2f}"
            caption += "\n"
        if sl_price:
            caption += f"ğŸ›‘ SL: ${sl_price:,.2f}"
        
        await query.message.reply_photo(
            photo=img_bytes,
            caption=caption
        )
        
        logger.info(f"âœ… Chart sent for {symbol} {tf}")
        
    except Exception as e:
        logger.error(f"âŒ Error generating chart: {e}")
        await query.answer(f"âŒ Error: {str(e)[:100]}", show_alert=True)

