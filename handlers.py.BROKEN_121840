#!/usr/bin/env python3
    )

import asyncio
    )

from datetime import datetime, timedelta
    )

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    )

# START COMMAND
    )

# ==========================================
    )


    )


    )

def create_quick_interval_buttons(symbol, current_timeframe, callback_prefix='analyze'):
    )

    """Create 3x3 grid of quick interval change buttons"""
    )

    intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M']
    )

    keyboard = []
    )

    
    )

    symbol_encoded = symbol.replace('/', '_').replace(':', '_')
    )

    
    )

    # 3 buttons per row
    )

    row = []
    )

    for i, tf in enumerate(intervals):
    )

        emoji = 'âœ…' if tf == current_timeframe else 'â±'
    )

        row.append(InlineKeyboardButton(
    )

            f'{emoji} {tf}',
    )

            callback_data=f'{callback_prefix}_{symbol_encoded}_{tf}'
    )

        ))
    )

        
    )

        if len(row) == 3 or i == len(intervals) - 1:
    )

            keyboard.append(row)
    )

            row = []
    )

    
    )

    return keyboard
    )


    )

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    )

    """Start command - main menu"""
    )

    user = update.effective_user
    )

    user_id = user.id
    )


    )

    # Get or create user
    )

    user_data = db.get_user(user_id)
    )

    if not user_data:
    )

        # Nowi uÅ¼ytkownicy dostajÄ… 7 dni premium
    )

        expires = (datetime.now() + timedelta(days=7)).isoformat()
    )

        user_data = {
    )

            'user_id': user_id,
    )

            'username': user.username or 'Unknown',
    )

            'first_name': user.first_name or '',
    )

            'selected_exchange': 'mexc',
    )

            'interval': '15m',
    )

            'is_premium': True,
    )

            'subscription_expires': expires,
    )

            'is_blocked': False,
    )

            'signals_count': 0,
    )

            'last_active': datetime.now().isoformat()
    )

        }
    )

        db.add_user(user_data)
    )

        logger.info(f"New user {user_id} created with 7 days premium")
    )


    )

    # Format status
    )

    sub_status = format_subscription_status(user_data.get('subscription_expires'), user_data.get('is_blocked', False))
    )

    is_admin = user_id in ADMIN_IDS
    )


    )

    welcome = f"""ğŸ‘‹ BOTrader Bot
    )


    )

Status: {sub_status}
    )

ğŸ†” ID: {user_id}
    )


    )

âœ¨ Wpisz nazwÄ™ pary (np. BTC) aby wyszukaÄ‡
    )

ğŸ“Š Lub uÅ¼yj menu poniÅ¼ej"""
    )


    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ” Wyszukaj parÄ™", callback_data='search_pair')],
    )

        [InlineKeyboardButton("ğŸ“Š Skaner ekstremÃ³w", callback_data='scan_extremes')],
    )

        [InlineKeyboardButton("ğŸ¯ SygnaÅ‚y AI", callback_data='ai_signals')],
    )

        [InlineKeyboardButton("ğŸ”” Alerty", callback_data='alerts_menu')],
    )

        [InlineKeyboardButton("ğŸ’¬ Czat z adminem", callback_data='admin_chat')],
    )

        [InlineKeyboardButton("âš™ï¸ Ustawienia", callback_data='settings')],
    )

        [InlineKeyboardButton("ğŸ’ Subskrypcja", callback_data='subscription')],
    )

        [InlineKeyboardButton("â„¹ï¸ WyjaÅ›nienia", callback_data='explanations_menu')],
    )

        [InlineKeyboardButton("â­ OceÅ„ bota", callback_data='rate_bot')]
    )

    ]
    )


    )

    if is_admin:
    )

        keyboard.append([InlineKeyboardButton("ğŸ‘‘ Admin Panel", callback_data='admin_panel')])
    )


    )

    await update.message.reply_text(welcome, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    )

    """Handle all button callbacks"""
    )

    query = update.callback_query
    )

    await query.answer()
    )

    
    )

    user_id = query.from_user.id
    )

    user = db.get_user(user_id)
    )

    
    )

    if not user:
    )

        await query.edit_message_text("âŒ UÅ¼ytkownik nie znaleziony. WyÅ›lij /start")
    )

        return
    )

    
    )

    data = query.data
    )

    
    )

    user['last_active'] = datetime.now().isoformat()
    )

    db.update_user(user_id, user)
    )

    
    )

    if data == 'back_main':
    )

        await start_command_from_callback(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'search_pair':
    )

        await search_pair_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'show_cached_scan':
    )

        await show_cached_scan(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'ai_signals':
    )

        await ai_signals_menu_advanced(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('ai_scan_'):
    )

        timeframe = data.replace('ai_scan_', '')
    )

        await ai_scan_select_size(query, user_id, user, timeframe)
    )

        return
    )

    
    )

    elif data.startswith('ai_run_'):
    )

        parts = data.replace('ai_run_', '').split('_')
    )

        timeframe = parts[0]
    )

        scan_size = parts[1] if len(parts) > 1 else 'top10'
    )

        await ai_scan_execute(query, user_id, user, timeframe, scan_size)
    )

        return
    )

    
    )


    )

    
    )

    elif data == 'rate_bot':
    )

        await rate_bot_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('rate_'):
    )

        stars = data.replace('rate_', '')
    )

        await query.answer(f"âœ… DziÄ™kujemy za {'â­' * int(stars)}!")
    )

        await start_command_from_callback(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'explanations_menu':
    )

        await explanations_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'scan_extremes':
    )

        await scan_extremes_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('scan_select_'):
    )

        # Menu wyboru rozmiaru
    )

        scan_type = data.replace('scan_select_', '')
    )

        await scan_size_menu(query, user_id, user, scan_type)
    )

        return
    )

    
    )

    elif data.startswith('scan_') and '_' in data:
    )

        # scan_TYPE_SIZE (np. scan_gainers_50)
    )

        parts = data.replace('scan_', '').rsplit('_', 1)
    )

        if len(parts) == 2:
    )

            scan_type = f'scan_{parts[0]}'
    )

            size_str = parts[1]
    )

            size = int(size_str) if size_str.isdigit() else 9999  # 'all' = 9999
    )

            await handle_scan(query, user_id, user, scan_type, size)
    )

        return
    )

    
    )

    elif data.startswith('scan_'):
    )

        # Stary format (fallback)
    )

        await handle_scan(query, user_id, user, data, 50)
    )

        return
    )

    
    )

    elif data == 'settings':
    )

        await settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'back_main':
    )

        await start_command_from_callback(query, user_id, user)
    )

        return
    )

    
    )


    )

    elif data.startswith('alert_detail_'):
    )

        index = int(data.replace('alert_detail_', ''))
    )

        await show_alert_detail(query, user_id, user, index)
    )

        return
    )

    elif data == 'alerts_menu':
    )

        await alerts_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_settings':
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_history':
    )

        await alerts_history_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('toggle_alert_'):
    )

        await query.answer()
    )

        alert_type = data.replace('toggle_alert_', '')
    )

        await toggle_alert(query, user_id, user, alert_type)
    )

        return
    )

    
    )

    elif data.startswith('set_scan_range_'):
    )

        range_val = int(data.replace('set_scan_range_', ''))
    )

        await set_scan_range(query, user_id, user, range_val)
    )

        return
    )

    
    )

    elif data.startswith('set_scan_freq_'):
    )

        freq = data.replace('set_scan_freq_', '')
    )

        await set_scan_frequency(query, user_id, user, freq)
    )

        return
    )

    
    )

    elif data == 'set_scan_range':
    )

        await set_scan_range(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'set_scan_frequency':
    )

        await set_scan_frequency(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'set_alert_timeframe':
    )

        await set_alert_timeframe(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'set_sudden_timeframe':
    )

        await set_sudden_timeframe_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('set_sudden_tf_'):
    )

        tf = data.replace('set_sudden_tf_', '')
    )

        await set_sudden_timeframe(query, user_id, user, tf)
    )

        return
    )

    
    )

    elif data == 'set_sudden_threshold':
    )

        await set_sudden_threshold_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('set_sudden_th_'):
    )

        threshold = int(data.replace('set_sudden_th_', ''))
    )

        await set_sudden_threshold(query, user_id, user, threshold)
    )

        return
    )

    
    )

    elif data.startswith('analyze_'):
    )

        await query.answer()
    )

        # Format: analyze_BTC_USDT_USDT_1h
    )

        parts = data.replace('analyze_', '').rsplit('_', 1)
    )

        symbol_encoded = parts[0]
    )

        timeframe = parts[1] if len(parts) > 1 else '1h'
    )

        
    )

        # Decode symbol
    )

        symbol = symbol_encoded.replace('_USDT_USDT', '/USDT:USDT').replace('_', '/')
    )

        
    )

        await analyze_from_alert(query, user_id, user, symbol, timeframe)
    )

        return
    )

    
    )

    elif data.startswith('set_alert_tf_'):
    )

        tf = data.replace('set_alert_tf_', '')
    )

        await set_alert_timeframe(query, user_id, user, tf)
    )

        return
    )

    
    )

    elif data == 'back_main':
    )

        await start_command_from_callback(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_menu':
    )

        await alerts_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_settings':
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_history':
    )

        await alerts_history_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('toggle_alert_'):
    )

        await query.answer()
    )

        alert_type = data.replace('toggle_alert_', '')
    )

        await toggle_alert(query, user_id, user, alert_type)
    )

        return
    )

    
    )

    elif data.startswith('set_scan_range_'):
    )

        range_val = int(data.replace('set_scan_range_', ''))
    )

        await set_scan_range(query, user_id, user, range_val)
    )

        return
    )

    
    )

    elif data.startswith('set_scan_freq_'):
    )

        freq = data.replace('set_scan_freq_', '')
    )

        await set_scan_frequency(query, user_id, user, freq)
    )

        return
    )

    
    )

    elif data == 'change_exchange':
    )

        await change_exchange_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('set_exchange_'):
    )

        exchange = data.replace('set_exchange_', '')
    )

        user['selected_exchange'] = exchange
    )

        db.update_user(user_id, user)
    )

        await query.answer(f"âœ… Zmieniono na {EXCHANGES[exchange]['name']}")
    )

        await settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'change_interval':
    )

        await change_interval_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('set_interval_'):
    )

        interval = data.replace('set_interval_', '')
    )

        user['interval'] = interval
    )

        db.update_user(user_id, user)
    )

        await query.answer(f"âœ… Zmieniono na {TIMEFRAMES[interval]['label']}")
    )

        await settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'language_menu':
    )

        await language_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('set_lang_'):
    )

        lang = data.replace('set_lang_', '')
    )

        user['language'] = lang
    )

        db.update_user(user_id, user)
    )

        from languages import LANGUAGES
    )

        await query.answer(f"âœ… Language changed to {LANGUAGES[lang]['name']}")
    )

        await settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'subscription':
    )

        await subscription_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'payment_info':
    )

        await payment_info_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'back_main':
    )

        await start_command_from_callback(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'alerts_menu':
    )

        await alerts_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'admin_chat':
    )

        await admin_chat_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'admin_panel':
    )

        if user_id not in ADMIN_IDS:
    )

            await query.answer("âŒ Brak dostÄ™pu")
    )

            return
    )

        await admin_panel_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'admin_stats':
    )

        await admin_stats_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data == 'admin_add_days':
    )

        await admin_add_days_menu(query, user_id, user)
    )

        return
    )

    
    )

    elif data.startswith('admin_user_'):
    )

        target_uid = int(data.replace('admin_user_', ''))
    )

        await admin_user_manage(query, user_id, target_uid)
    )

        return
    )

    
    )

    elif data.startswith('admin_give_'):
    )

        parts = data.replace('admin_give_', '').split('_')
    )

        target_uid = int(parts[0])
    )

        days = int(parts[1])
    )

        await admin_give_days(query, user_id, target_uid, days)
    )

        return
    )

    
    )

    elif data.startswith('admin_promo_all_'):
    )

        days = int(data.replace('admin_promo_all_', ''))
    )

        await admin_promo_all(query, user_id, days)
    )

        return
    )

    
    )

    elif data == 'ignore':
    )

        await query.answer()
    )

        return
    )

    
    )

    elif data.startswith('analyze_'):
    )

        await query.answer()
    )

        # analyze_SYMBOL_TIMEFRAME lub analyze_SYMBOL (default 15m)
    )

        parts = data.replace('analyze_', '').split('_')
    )

        symbol = parts[0]
    )

        timeframe = parts[1] if len(parts) > 1 else user.get('interval', '15m')
    )

        exchange = user.get('selected_exchange', 'mexc').lower()
    )

        
    )

        # Dodaj /USDT jeÅ›li brak
    )

        if '/USDT' not in symbol:
    )

            symbol = symbol + '/USDT'
    )

        
    )

        await show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, 'manual')
    )

        return
    )

    
    )

    elif data.startswith('ai_sig_'):
    )

        # ai_sig_SYMBOL_TIMEFRAME - z kontekstem AI signals
    )

        parts = data.replace('ai_sig_', '').split('_')
    )

        symbol = parts[0]
    )

        timeframe = parts[1] if len(parts) > 1 else user.get('interval', '15m')
    )

        exchange = user.get('selected_exchange', 'mexc').lower()
    )

        
    )

        # Dodaj /USDT
    )

        if '/USDT' not in symbol:
    )

            symbol = symbol + '/USDT'
    )

        
    )

        await show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, 'ai_signal')
    )

        return
    )

    
    )

    elif data.startswith('details_'):
    )

        # Pokazuje wiÄ™cej szczegÃ³Å‚Ã³w
    )

        parts = data.replace('details_', '').split('_')
    )

        symbol = parts[0]
    )

        timeframe = parts[1] if len(parts) > 1 else '15m'
    )

        await query.answer("ğŸ”§ SzczegÃ³Å‚owa analiza - w przygotowaniu!")
    )

        return
    )


    )

# ==========================================
    )

# SCAN EXTREMES
    )

# ==========================================
    )

async def scan_extremes_menu(query, user_id, user):
    )

    """Scan extremes menu"""
    )

    text = """ğŸ“Š SKANER EKSTREMÃ“W
    )


    )

Wybierz typ skanowania:
    )


    )

ğŸš€ Wzrosty - najwiÄ™ksze wzrosty ceny
    )

ğŸ“‰ Spadki - najwiÄ™ksze spadki ceny
    )

ğŸ”¥ RSI < 30 - oversold
    )

ğŸ’ RSI > 70 - overbought
    )

ğŸ“ˆ Volume - najwiÄ™kszy wolumen"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸš€ Wzrosty", callback_data='scan_select_gainers')],
    )

        [InlineKeyboardButton("ğŸ“‰ Spadki", callback_data='scan_select_losers')],
    )

        [InlineKeyboardButton("ğŸ”¥ RSI Oversold", callback_data='scan_select_rsi_oversold')],
    )

        [InlineKeyboardButton("ğŸ’ RSI Overbought", callback_data='scan_select_rsi_overbought')],
    )

        [InlineKeyboardButton("ğŸ“ˆ Volume TOP", callback_data='scan_select_volume')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def scan_size_menu(query, user_id, user, scan_type):
    )

    """Menu wyboru rozmiaru skanowania"""
    )

    
    )

    scan_names = {
    )

        'gainers': 'ğŸš€ WZROSTY',
    )

        'losers': 'ğŸ“‰ SPADKI',
    )

        'rsi_oversold': 'ğŸ”¥ RSI OVERSOLD',
    )

        'rsi_overbought': 'ğŸ’ RSI OVERBOUGHT',
    )

        'volume': 'ğŸ“ˆ VOLUME TOP'
    )

    }
    )

    
    )

    text = f"""ğŸ“Š {scan_names.get(scan_type, 'SKANER')}
    )


    )

Wybierz zakres skanowania:
    )


    )

â€¢ TOP 50 - szybkie (~10 sek)
    )

â€¢ TOP 100 - Å›rednie (~20 sek)
    )

â€¢ TOP 200 - wolne (~40 sek)
    )

â€¢ WSZYSTKIE - najdokÅ‚adniejsze (~2 min)
    )


    )

Im wiÄ™cej par, tym lepsze okazje! ğŸ’"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('âš¡ TOP 50 (~10s)', callback_data=f'scan_{scan_type}_50')],
    )

        [InlineKeyboardButton('ğŸ“Š TOP 100 (~20s)', callback_data=f'scan_{scan_type}_100')],
    )

        [InlineKeyboardButton('ğŸ” TOP 200 (~40s)', callback_data=f'scan_{scan_type}_200')],
    )

        [InlineKeyboardButton('ğŸ’ WSZYSTKIE (~2min)', callback_data=f'scan_{scan_type}_all')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='scan_extremes')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def handle_scan(query, user_id, user, scan_type, scan_size=50):
    )

    """Handle scanning"""
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    interval = user.get('interval', '15m')
    )

    
    )

    await query.edit_message_text(f"ğŸ” SkanujÄ™ {EXCHANGES[exchange]['name']}...\n\nCzekaj...")
    )

    
    )

    try:
    )

        symbols = await exchange_api.get_symbols(exchange)
    )

        
    )

        if not symbols:
    )

            await query.edit_message_text("âŒ BÅ‚Ä…d pobierania par", reply_markup=back_button('scan_extremes'))
    )

            return
    )

        
    )

        results = []
    )

        
    )

        # Limit do wybranego rozmiaru
    )

        scan_limit = min(scan_size, len(symbols)) if scan_size < 9999 else len(symbols)
    )

        logger.info(f'Scanning {scan_limit}/{len(symbols)} pairs')
    )

        
    )

        for symbol in list(symbols)[:scan_limit]:
    )

            try:
    )

                data = await exchange_api.get_ohlcv(symbol, exchange, interval)
    )

                
    )

                if not data or len(data) < 2:
    )

                    continue
    )

                
    )

                current_price = data[-1][4]
    )

                prev_price = data[-2][4]
    )

                change_pct = ((current_price - prev_price) / prev_price) * 100
    )

                
    )

                closes = [candle[4] for candle in data[-14:]]
    )

                gains = [closes[i] - closes[i-1] for i in range(1, len(closes)) if closes[i] > closes[i-1]]
    )

                losses = [closes[i-1] - closes[i] for i in range(1, len(closes)) if closes[i] < closes[i-1]]
    )

                
    )

                avg_gain = sum(gains) / len(gains) if gains else 0
    )

                avg_loss = sum(losses) / len(losses) if losses else 0
    )

                
    )

                if avg_loss == 0:
    )

                    rsi = 100
    )

                else:
    )

                    rs = avg_gain / avg_loss
    )

                    rsi = 100 - (100 / (1 + rs))
    )

                
    )

                volume = data[-1][5]
    )

                
    )

                result = {
    )

                    'symbol': symbol,
    )

                    'price': current_price,
    )

                    'change': change_pct,
    )

                    'rsi': rsi,
    )

                    'volume': volume
    )

                }
    )

                
    )

                if scan_type == 'scan_gainers' and change_pct > 0:
    )

                    results.append(result)
    )

                elif scan_type == 'scan_losers' and change_pct < 0:
    )

                    results.append(result)
    )

                elif scan_type == 'scan_rsi_oversold' and rsi < 20:
    )

                    results.append(result)
    )

                elif scan_type == 'scan_rsi_overbought' and rsi > 80:
    )

                    results.append(result)
    )

                elif scan_type == 'scan_volume':
    )

                    results.append(result)
    )

                
    )

            except Exception as e:
    )

                logger.error(f"Scan error for {symbol}: {e}")
    )

                continue
    )

        
    )

        if not results:
    )

            await query.edit_message_text("âŒ Brak wynikÃ³w", reply_markup=back_button('scan_extremes'))
    )

            return
    )

        
    )

        if scan_type in ['scan_gainers', 'scan_losers']:
    )

            results.sort(key=lambda x: abs(x['change']), reverse=True)
    )

        elif scan_type in ['scan_rsi_oversold', 'scan_rsi_overbought']:
    )

            results.sort(key=lambda x: x['rsi'])
    )

        elif scan_type == 'scan_volume':
    )

            results.sort(key=lambda x: x['volume'], reverse=True)
    )

        
    )

        top_results = results[:10]
    )

        
    )

        # Get user language
    )

        lang = get_user_language(user)
    )

        
    )

        scan_names = {
    )

            'scan_gainers': f"ğŸš€ {t('gainers', lang)}",
    )

            'scan_losers': f"ğŸ“‰ {t('losers', lang)}",
    )

            'scan_rsi_oversold': f"ğŸ”¥ {t('rsi_oversold', lang)}",
    )

            'scan_rsi_overbought': f"ğŸ’ {t('rsi_overbought', lang)}",
    )

            'scan_volume': f"ğŸ“ˆ {t('volume_top', lang)}"
    )

        }
    )

        
    )

        text = f"{scan_names.get(scan_type, 'SKANER')}\n{EXCHANGES[exchange]['name']} | {TIMEFRAMES[interval]['label']}\n\n"
    )

        text += f"{t('found_pairs', lang)}: {len(results)} {t('pairs', lang)}\n{t('top_10', lang)}:\n"
    )

        
    )

        keyboard = []
    )

        
    )

        for r in top_results:
    )

            display_symbol = r["symbol"].replace(":USDT", "")
    )

            symbol = display_symbol
    )

            price = r['price']
    )

            change = r['change']
    )

            rsi = r['rsi']
    )

            
    )

            if scan_type in ['scan_gainers', 'scan_losers']:
    )

                label = f"{'ğŸŸ¢' if change > 0 else 'ğŸ”´'} {symbol} | {change:+.2f}%"
    )

            else:
    )

                label = f"ğŸ“Š {symbol} | RSI {rsi:.0f}"
    )

            
    )

            keyboard.append([InlineKeyboardButton(label, callback_data=f'analyze_{symbol}')])
    )

        
    )

        keyboard.append([InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data=scan_type)])
    )

        keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='scan_extremes')])
    )

        
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

        user['signals_count'] = user.get('signals_count', 0) + 1
    )

        db.update_user(user_id, user)
    )

        
    )

    except Exception as e:
    )

        logger.error(f"Scan error: {e}")
    )

        await query.edit_message_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button('scan_extremes'))
    )


    )

# ==========================================
    )

# SETTINGS
    )

# ==========================================
    )

async def settings_menu(query, user_id, user):
    )

    """Settings menu"""
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    interval = user.get('interval', '15m')
    )

    
    )

    lang = get_user_language(user)
    )

    
    )

    text = f"""âš™ï¸ {t('settings', lang).upper()}
    )


    )

ğŸŒ {t('exchange', lang)}: {EXCHANGES[exchange]['name']}
    )

â° {t('interval', lang)}: {TIMEFRAMES[interval]['label']}"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸŒ JÄ™zyk / Language", callback_data='language_menu')],
    )

        [InlineKeyboardButton(t('change_exchange', lang), callback_data='change_exchange')],
    )

        [InlineKeyboardButton(t('change_interval', lang), callback_data='change_interval')],
    )

        [InlineKeyboardButton(t('back', lang), callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def change_exchange_menu(query, user_id, user):
    )

    """Change exchange"""
    )

    text = "ğŸŒ WYBIERZ GIEÅDÄ˜\n\nDostÄ™pne gieÅ‚dy:"
    )

    
    )

    keyboard = []
    )

    for ex_id, ex_data in EXCHANGES.items():
    )

        keyboard.append([InlineKeyboardButton(f"{ex_data['name']}", callback_data=f'set_exchange_{ex_id}')])
    )

    
    )

    keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='settings')])
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def change_interval_menu(query, user_id, user):
    )

    """Change interval"""
    )

    text = "â°  WYBIERZ INTERWAÅ"
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('1m', callback_data='set_interval_1m'), InlineKeyboardButton('5m', callback_data='set_interval_5m'), InlineKeyboardButton('15m', callback_data='set_interval_15m')],
    )

        [InlineKeyboardButton('30m', callback_data='set_interval_30m'), InlineKeyboardButton('1h', callback_data='set_interval_1h'), InlineKeyboardButton('4h', callback_data='set_interval_4h')],
    )

        [InlineKeyboardButton('8h', callback_data='set_interval_8h'), InlineKeyboardButton('1d', callback_data='set_interval_1d'), InlineKeyboardButton('1w', callback_data='set_interval_1w')],
    )

        [InlineKeyboardButton('1M', callback_data='set_interval_1M')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='settings')]
    )

    ]
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

# ==========================================
    )

# SUBSCRIPTION
    )

# ==========================================
    )

async def subscription_menu(query, user_id, user):
    )

    """Subscription menu"""
    )

    sub_status = format_subscription_status(user.get('subscription_expires'), user.get('is_blocked', False))
    )

    
    )

    text = f"""ğŸ’ SUBSKRYPCJA
    )


    )

ğŸ†” ID: {user_id}
    )

ğŸ“… Status: {sub_status}
    )


    )

âœ¨ PREMIUM:
    )

â€¢ ğŸ¯ Nielimitowane sygnaÅ‚y AI
    )

â€¢ ğŸ”” Nielimitowane alerty
    )

â€¢ ğŸ“Š 16 timeframe'Ã³w
    )

â€¢ ğŸš€ Priorytet wsparcia
    )


    )

ğŸ’° PAKIETY:
    )

â€¢ 7 dni - 50 PLN / 12 USDT
    )

â€¢ 30 dni - 150 PLN / 35 USDT â­
    )

â€¢ 90 dni - 350 PLN / 80 USDT ğŸ”¥ -20%
    )

â€¢ 365 dni - 1000 PLN / 230 USDT ğŸ’ -50%
    )


    )

ğŸ’¬ Kontakt: @YOUR_ADMIN"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ’³ Metody pÅ‚atnoÅ›ci", callback_data='payment_info')],
    )

        [InlineKeyboardButton("ğŸ’¬ Kontakt z adminem", callback_data='admin_chat')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def payment_info_menu(query, user_id, user):
    )

    """Payment info"""
    )

    text = f"""ğŸ’³ METODY PÅATNOÅšCI
    )


    )

ğŸ¦ BLIK / Przelew bankowy (PLN)
    )

   â†’ Szybki kontakt z adminem
    )


    )

ğŸ’ USDT (TRC20)
    )

   â†’ Adres: `{USDT_ADDRESS}`
    )

   â†’ Natychmiastowa aktywacja
    )


    )

ğŸ“ Proces:
    )

1. Wybierz pakiet
    )

2. Napisz do admina
    )

3. WyÅ›lij pÅ‚atnoÅ›Ä‡
    )

4. Aktywacja!
    )


    )

ğŸ’¬ Kontakt: @YOUR_ADMIN"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ’¬ Napisz do admina", callback_data='admin_chat')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='subscription')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
    )


    )

# ==========================================
    )

# ALERTS
    )

# ==========================================
    )

async def alerts_menu(query, user_id, user):
    )

    """Alerts menu"""
    )

    text = """ğŸ”” ALERTY
    )


    )

Funkcja w przygotowaniu!
    )


    )

WkrÃ³tce dostÄ™pne:
    )

â€¢ ğŸ’° Alert cenowy
    )

â€¢ ğŸ“Š Alert RSI
    )

â€¢ ğŸ“ˆ Alert MACD
    )


    )

Zostaniesz powiadomiony! ğŸš€"""
    )

    
    )

    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

# ==========================================
    )

# ADMIN CHAT
    )

# ==========================================
    )

async def admin_chat_menu(query, user_id, user):
    )

    """Admin chat"""
    )

    text = f"""ğŸ’¬ CZAT Z ADMINEM
    )


    )

ğŸ†” Twoje ID: {user_id}
    )


    )

Napisz swojÄ… wiadomoÅ›Ä‡ w nastÄ™pnej wiadomoÅ›ci.
    )

Admin odpowie bezpoÅ›rednio.
    )


    )

ğŸ“ MoÅ¼esz wysÅ‚aÄ‡:
    )

â€¢ Tekst
    )

â€¢ ZdjÄ™cia
    )

â€¢ Dokumenty"""
    )

    
    )

    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

    
    )

    user['awaiting_admin_message'] = True
    )

    db.update_user(user_id, user)
    )


    )

# ==========================================
    )

# ADMIN PANEL
    )

# ==========================================
    )

async def admin_panel_menu(query, user_id, user):
    )

    """Admin panel"""
    )

    if user_id not in ADMIN_IDS:
    )

        await query.answer("âŒ Brak dostÄ™pu")
    )

        return
    )

    
    )

    total_users = db.get_user_count()
    )

    active_users = len(db.get_active_users(7))
    )

    
    )

    text = f"""ğŸ‘¨â€ğŸ’¼ PANEL ADMINA
    )


    )

ğŸ“Š Statystyki:
    )

â€¢ UÅ¼ytkownicy: {total_users}
    )

â€¢ Aktywni (7 dni): {active_users}
    )


    )

âš™ï¸ ZarzÄ…dzanie:"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ“Š Statystyki", callback_data='admin_stats')],
    )

        [InlineKeyboardButton("â• Dodaj dni", callback_data='admin_add_days')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def admin_stats_menu(query, user_id, user):
    )

    """Admin statistics"""
    )

    all_users_dict = db.get_all_users()
    )

    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    )

    total = len(all_users)
    )

    active_7d = len(db.get_active_users(7))
    )

    premium = sum(1 for u in all_users if u.get('is_premium', False))
    )

    total_signals = sum(u.get('signals_count', 0) for u in all_users)
    )

    
    )

    text = f"""ğŸ“Š STATYSTYKI
    )


    )

ğŸ‘¥ UÅ¼ytkownicy:
    )

â€¢ Wszyscy: {total}
    )

â€¢ Aktywni 7d: {active_7d}
    )

â€¢ Premium: {premium}
    )


    )

ğŸ“ˆ AktywnoÅ›Ä‡:
    )

â€¢ SygnaÅ‚y: {total_signals}
    )

â€¢ Åšrednio/user: {total_signals / total if total > 0 else 0:.1f}"""
    )

    
    )

    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='admin_panel')]]
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def admin_add_days_menu(query, user_id, user):
    )

    """Add days - show users list"""
    )

    all_users_dict = db.get_all_users()
    )

    # Convert dict to list
    )

    all_users = list(all_users_dict.values()) if isinstance(all_users_dict, dict) else all_users_dict
    )

    all_users.sort(key=lambda u: u.get('last_active', ''), reverse=True)
    )

    
    )

    text = f"""â• DODAJ DNI SUBSKRYPCJI
    )


    )

ğŸ‘¥ UÅ¼ytkownikÃ³w: {len(all_users)}
    )


    )

Kliknij uÅ¼ytkownika:"""
    )

    
    )

    keyboard = []
    )

    
    )

    keyboard.append([InlineKeyboardButton('ğŸ +7 dni WSZYSTKIM', callback_data='admin_promo_all_7')])
    )

    keyboard.append([InlineKeyboardButton('ğŸ +30 dni WSZYSTKIM', callback_data='admin_promo_all_30')])
    )

    keyboard.append([InlineKeyboardButton('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', callback_data='ignore')])
    )

    
    )

    # UsuÅ„ duplikaty po user_id
    )

    seen_ids = set()
    )

    unique_users = []
    )

    for u in all_users:
    )

        if u['user_id'] not in seen_ids:
    )

            seen_ids.add(u['user_id'])
    )

            unique_users.append(u)
    )

    
    )

    for u in unique_users[:15]:
    )

        uid = u['user_id']
    )

        username = u.get('username', 'Brak')
    )

        
    )

        sub_expires = u.get('subscription_expires')
    )

        is_premium = u.get('is_premium', False)
    )

        
    )

        if is_premium and sub_expires:
    )

            try:
    )

                expires_date = datetime.fromisoformat(sub_expires)
    )

                days_left = (expires_date - datetime.now()).days
    )

                status = f"ğŸ’ {days_left}d"
    )

            except:
    )

                status = "âš ï¸ 0d"
    )

        else:
    )

            status = "âš ï¸ 0d"
    )

        
    )

        keyboard.append([InlineKeyboardButton(
    )

            f"{status} {uid} @{username}",
    )

            callback_data=f"admin_user_{uid}"
    )

        )])
    )

    
    )

    keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='admin_panel')])
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def admin_user_manage(query, user_id, target_user_id):
    )

    """Manage specific user"""
    )

    if user_id not in ADMIN_IDS:
    )

        return
    )

    
    )

    target_user = db.get_user(target_user_id)
    )

    username = target_user.get('username', 'Brak')
    )

    
    )

    sub_expires = target_user.get('subscription_expires')
    )

    is_premium = target_user.get('is_premium', False)
    )

    
    )

    if is_premium and sub_expires:
    )

        try:
    )

            expires_date = datetime.fromisoformat(sub_expires)
    )

            days_left = (expires_date - datetime.now()).days
    )

            status = f"ğŸ’ {days_left} dni"
    )

        except:
    )

            status = "âš ï¸ Brak"
    )

    else:
    )

        status = "âš ï¸ Brak"
    )

    
    )

    text = f"""ğŸ‘¤ ZARZÄ„DZAJ
    )


    )

ğŸ†” ID: {target_user_id}
    )

ğŸ‘¤ @{username}
    )

ğŸ“… Status: {status}
    )


    )

Wybierz akcjÄ™:"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('â• +7 dni', callback_data=f'admin_give_{target_user_id}_7')],
    )

        [InlineKeyboardButton('â• +30 dni', callback_data=f'admin_give_{target_user_id}_30')],
    )

        [InlineKeyboardButton('â• +90 dni', callback_data=f'admin_give_{target_user_id}_90')],
    )

        [InlineKeyboardButton('â• +365 dni', callback_data=f'admin_give_{target_user_id}_365')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='admin_add_days')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def admin_give_days(query, user_id, target_user_id, days):
    )

    """Give days to user"""
    )

    if user_id not in ADMIN_IDS:
    )

        return
    )

    
    )

    target_user = db.get_user(target_user_id)
    )

    
    )

    current_expires = target_user.get('subscription_expires')
    )

    if current_expires:
    )

        try:
    )

            expires_date = datetime.fromisoformat(current_expires)
    )

        except:
    )

            expires_date = datetime.now()
    )

    else:
    )

        expires_date = datetime.now()
    )

    
    )

    new_expires = expires_date + timedelta(days=days)
    )

    
    )

    target_user['subscription_expires'] = new_expires.isoformat()
    )

    target_user['is_premium'] = True
    )

    db.update_user(target_user_id, target_user)
    )

    
    )

    try:
    )

        await query.bot.send_message(
    )

            chat_id=target_user_id,
    )

            text=f"""ğŸ‰ GRATULACJE!
    )


    )

Admin dodaÅ‚ Ci {days} dni Premium!
    )


    )

ğŸ’ Data wygaÅ›niÄ™cia: {new_expires.strftime('%Y-%m-%d')}
    )


    )

DziÄ™kujemy! â¤ï¸"""
    )

        )
    )

    except:
    )

        pass
    )

    
    )

    await query.answer(f"âœ… Dodano {days} dni dla {target_user_id}")
    )

    await admin_user_manage(query, user_id, target_user_id)
    )


    )

async def admin_promo_all(query, user_id, days):
    )

    """Promo - give days to ALL"""
    )

    if user_id not in ADMIN_IDS:
    )

        return
    )

    
    )

    await query.edit_message_text(f"ğŸ DodajÄ™ {days} dni WSZYSTKIM...")
    )

    
    )

    all_users = db.get_all_users()
    )

    success = 0
    )

    
    )

    for target_user in all_users:
    )

        target_user_id = target_user['user_id']
    )

        
    )

        current_expires = target_user.get('subscription_expires')
    )

        if current_expires:
    )

            try:
    )

                expires_date = datetime.fromisoformat(current_expires)
    )

            except:
    )

                expires_date = datetime.now()
    )

        else:
    )

            expires_date = datetime.now()
    )

        
    )

        new_expires = expires_date + timedelta(days=days)
    )

        
    )

        target_user['subscription_expires'] = new_expires.isoformat()
    )

        target_user['is_premium'] = True
    )

        db.update_user(target_user_id, target_user)
    )

        
    )

        try:
    )

            await query.bot.send_message(
    )

                chat_id=target_user_id,
    )

                text=f"""ğŸ PROMOCJA SPECJALNA!
    )


    )

OtrzymaÅ‚eÅ› {days} dni Premium GRATIS!
    )


    )

ğŸ’ DziÄ™kujemy za bycie z nami! â¤ï¸"""
    )

            )
    )

            success += 1
    )

        except:
    )

            pass
    )

    
    )

    await query.edit_message_text(
    )

        f"""âœ… PROMOCJA ZAKOÅƒCZONA
    )


    )

WysÅ‚ano: {success}/{len(all_users)} uÅ¼ytkownikÃ³w
    )

Dni dodane: {days}""",
    )

        reply_markup=back_button('admin_panel')
    )

    )
    )


    )

# ==========================================
    )

# TEXT MESSAGE HANDLER
    )

# ==========================================
    )

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    )

    user_id = update.message.from_user.id
    )

    user = db.get_user(user_id)
    )

    text = update.message.text.strip()
    )


    )

    # ğŸ” SEARCH PAIR FLOW
    )

    if user.get("awaiting_search"):
    )

        user["awaiting_search"] = False
    )

        db.update_user(user_id, user)
    )

        await search_pair_execute(update, user_id, user, text)
    )

        return
    )


    )

    """Handle text messages - search pairs or admin messages"""
    )

    user_id = update.effective_user.id
    )

    user = db.get_user(user_id)
    )

    
    )

    if not user:
    )

        await update.message.reply_text("âŒ WyÅ›lij /start aby rozpoczÄ…Ä‡")
    )

        return
    )

    
    )

    if user.get('awaiting_admin_message'):
    )

        await handle_admin_message_forward(update, context, user_id, user)
    )

        return
    )

    
    )

    search_term = update.message.text.strip().upper()
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    
    )

    await update.message.reply_text(f"ğŸ” Szukam '{search_term}' na {EXCHANGES[exchange]['name']}...")
    )

    
    )

    try:
    )

        symbols = await exchange_api.get_symbols(exchange)
    )

        
    )

        if not symbols:
    )

            await update.message.reply_text("âŒ BÅ‚Ä…d pobierania par", reply_markup=back_button())
    )

            return
    )

        
    )

        matching = [s for s in symbols if search_term in s.upper()]
    )

        
    )

        if not matching:
    )

            await update.message.reply_text(f"âŒ Nie znaleziono par zawierajÄ…cych '{search_term}'", reply_markup=back_button())
    )

            return
    )

        
    )

        text = f"ğŸ” WYNIKI WYSZUKIWANIA\n\nZnaleziono: {len(matching)} par\n\n"
    )

        
    )

        keyboard = []
    )

        
    )

        for symbol in matching[:20]:
    )

            display_symbol = symbol.replace(':USDT', '')
    )

            keyboard.append([InlineKeyboardButton(f"ğŸ“Š {display_symbol}", callback_data=f'analyze_{symbol}')])
    )

        
    )

        keyboard.append([InlineKeyboardButton('â¬…ï¸ Menu', callback_data='back_main')])
    )

        
    )

        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

    except Exception as e:
    )

        logger.error(f"Search error: {e}")
    )

        await update.message.reply_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button())
    )


    )

async def handle_admin_message_forward(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id, user):
    )

    """Forward message to admin"""
    )

    if not ADMIN_IDS:
    )

        await update.message.reply_text("âŒ Brak skonfigurowanego admina")
    )

        return
    )

    
    )

    admin_id = ADMIN_IDS[0]
    )

    username = update.effective_user.username or "Brak username"
    )

    first_name = update.effective_user.first_name or "User"
    )

    
    )

    try:
    )

        header = f"ğŸ’¬ WiadomoÅ›Ä‡ od:\n\n"
    )

        header += f"ğŸ‘¤ {first_name} (@{username})\n"
    )

        header += f"ğŸ†” ID: {user_id}\n"
    )

        header += f"{'='*30}\n\n"
    )

        
    )

        await context.bot.send_message(chat_id=admin_id, text=header)
    )

        
    )

        await update.message.forward(admin_id)
    )

        
    )

        await update.message.reply_text(
    )

            "âœ… WiadomoÅ›Ä‡ wysÅ‚ana!\n\nAdmin odpowie najszybciej jak to moÅ¼liwe.",
    )

            reply_markup=back_button()
    )

        )
    )

        
    )

        user['awaiting_admin_message'] = False
    )

        db.update_user(user_id, user)
    )

        
    )

    except Exception as e:
    )

        logger.error(f"Forward error: {e}")
    )

        await update.message.reply_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button())
    )


    )

# ==========================================
    )

# START FROM CALLBACK
    )

# ==========================================
    )

async def start_command_from_callback(query, user_id, user):
    )

    """Start command from callback (recreate menu)"""
    )

    sub_status = format_subscription_status(user.get('subscription_expires'), user.get('is_blocked', False))
    )

    is_admin = user_id in ADMIN_IDS
    )

    
    )

    welcome = f"""ğŸ‘‹ BOTrader Bot
    )


    )

Status: {sub_status}
    )

ğŸ†” ID: {user_id}
    )


    )

âœ¨ Wpisz nazwÄ™ pary (np. BTC) aby wyszukaÄ‡
    )

ğŸ“Š Lub uÅ¼yj menu poniÅ¼ej"""
    )


    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ” Wyszukaj parÄ™", callback_data='search_pair')],
    )

        [InlineKeyboardButton("ğŸ“Š Skaner ekstremÃ³w", callback_data='scan_extremes')],
    )

        [InlineKeyboardButton("ğŸ¯ SygnaÅ‚y AI", callback_data='ai_signals')],
    )

        [InlineKeyboardButton("ğŸ”” Alerty", callback_data='alerts_menu')],
    )

        [InlineKeyboardButton("ğŸ’¬ Czat z adminem", callback_data='admin_chat')],
    )

        [InlineKeyboardButton("âš™ï¸ Ustawienia", callback_data='settings')],
    )

        [InlineKeyboardButton("ğŸ’ Subskrypcja", callback_data='subscription')],
    )

        [InlineKeyboardButton("â„¹ï¸ WyjaÅ›nienia", callback_data='explanations_menu')],
    )

        [InlineKeyboardButton("â­ OceÅ„ bota", callback_data='rate_bot')]
    )

    ]
    )

    
    )

    if is_admin:
    )

        keyboard.append([InlineKeyboardButton("ğŸ‘¨â€ğŸ’¼ Admin", callback_data='admin_panel')])
    )

    
    )

    keyboard.append([
    )

        InlineKeyboardButton("ğŸ“Š MEXC", url='https://promote.mexc.com/r/gspEf2nl'),
    )

        InlineKeyboardButton("ğŸ“Š Bybit", url='https://www.bybit.com/invite?ref=64NXL'),
    )

        InlineKeyboardButton("ğŸ“Š Binance", url='https://www.binance.com/activity/referral-entry/CPA?ref=CPA_00J86WYYZV')
    )

    ])
    )

    
    )

    await query.edit_message_text(welcome, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

logger.info("âœ… Handlers initialized")
    )


    )

# ==========================================
    )

# SEARCH PAIR MENU
    )

# ==========================================
    )

async def search_pair_menu(query, user_id, user):

# ==========================================
# SEARCH PAIR EXECUTION
# ==========================================
    )


    )

    """Search pair menu"""
    )

    text = """ğŸ” WYSZUKAJ PARÄ˜
    )


    )

Wpisz nazwÄ™ kryptowaluty (np. BTC, ETH, SOL)
    )


    )

Bot znajdzie wszystkie pary z USDT na wybranej gieÅ‚dzie.
    )


    )

ğŸ’¡ MoÅ¼esz teÅ¼ wpisaÄ‡ nazwÄ™ w dowolnym momencie bez klikania tego przycisku!"""
    )

    
    )

    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

    
    )

    user['awaiting_search'] = True
    )

    db.update_user(user_id, user)
    )


    )

# ==========================================
    )

# AI SIGNALS MENU
    )

# ==========================================
    )

async def ai_signals_menu(query, user_id, user):
    )

    """AI Signals menu"""
    )

    text = """ğŸ¯ SYGNAÅY AI
    )


    )

Wybierz timeframe:
    )


    )

Bot przeanalizuje TOP pary uÅ¼ywajÄ…c:
    )

â€¢ DeepSeek AI - analiza techniczna
    )

â€¢ RSI, MACD, Volume
    )

â€¢ Support/Resistance
    )

â€¢ Rekomendacje TP1/TP2/TP3"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ“Š 15m", callback_data='ai_15m'), InlineKeyboardButton("ğŸ“Š 1h", callback_data='ai_1h')],
    )

        [InlineKeyboardButton("ğŸ“Š 4h", callback_data='ai_4h'), InlineKeyboardButton("ğŸ“Š 1d", callback_data='ai_1d')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

# ==========================================
    )

# RATE BOT MENU
    )

# ==========================================
    )

async def rate_bot_menu(query, user_id, user):
    )

    """Rate bot menu"""
    )

    text = """â­ OCEÅƒ BOTA
    )


    )

PomÃ³Å¼ nam siÄ™ rozwijaÄ‡!
    )


    )

ğŸ“ Twoja opinia:
    )

â€¢ Co dziaÅ‚a Å›wietnie?
    )

â€¢ Co moÅ¼na poprawiÄ‡?
    )

â€¢ Jakie funkcje dodaÄ‡?
    )


    )

ğŸ’¬ Napisz swojÄ… opiniÄ™ w nastÄ™pnej wiadomoÅ›ci lub kliknij poniÅ¼ej:"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("â­â­â­â­â­ Åšwietny!", callback_data='rate_5')],
    )

        [InlineKeyboardButton("â­â­â­â­ Dobry", callback_data='rate_4')],
    )

        [InlineKeyboardButton("â­â­â­ OK", callback_data='rate_3')],
    )

        [InlineKeyboardButton("ğŸ’¬ Napisz opiniÄ™", callback_data='admin_chat')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

logger.info("âœ… New menu handlers added")
    )


    )

# ==========================================
    )

# ADVANCED AI SIGNALS
    )

# ==========================================
    )

from ai_signals_advanced import advanced_ai_signals
    )


    )

async def ai_signals_menu_advanced(query, user_id, user):
    )

    """Advanced AI Signals menu"""
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    
    )

    text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
    )


    )

â± Wybierz TIMEFRAME:
    )

(czas w jakim sygnaÅ‚ siÄ™ sprawdzi)
    )


    )

ğŸ“Š Skanowanie z filtrami:
    )

â€¢ Volume + Volatility + LikwidnoÅ›Ä‡
    )

â€¢ Multi-timeframe analysis
    )

â€¢ DeepSeek AI + wskaÅºniki"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("âš¡ 1m", callback_data='ai_scan_1m'), InlineKeyboardButton("âš¡ 3m", callback_data='ai_scan_3m'), InlineKeyboardButton("âš¡ 5m", callback_data='ai_scan_5m')],
    )

        [InlineKeyboardButton("ğŸ“Š 15m", callback_data='ai_scan_15m'), InlineKeyboardButton("ğŸ“Š 30m", callback_data='ai_scan_30m'), InlineKeyboardButton("ğŸ“Š 1h", callback_data='ai_scan_1h')],
    )

        [InlineKeyboardButton("ğŸ“ˆ 2h", callback_data='ai_scan_2h'), InlineKeyboardButton("ğŸ“ˆ 4h", callback_data='ai_scan_4h'), InlineKeyboardButton("ğŸ“ˆ 8h", callback_data='ai_scan_8h')],
    )

        [InlineKeyboardButton("ğŸ”¥ 12h", callback_data='ai_scan_12h'), InlineKeyboardButton("ğŸ”¥ 1d", callback_data='ai_scan_1d'), InlineKeyboardButton("ğŸ”¥ 3d", callback_data='ai_scan_3d')],
    )

        [InlineKeyboardButton("ğŸ’ 1w", callback_data='ai_scan_1w'), InlineKeyboardButton("ğŸ’ 2w", callback_data='ai_scan_2w'), InlineKeyboardButton("ğŸ’ 1M", callback_data='ai_scan_1M')],
    )

        [InlineKeyboardButton("âš™ï¸ Ustawienia skanowania", callback_data='ai_scan_settings')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def ai_scan_settings_menu(query, user_id, user):
    )

    """Scan settings"""
    )

    text = """âš™ï¸ USTAWIENIA SKANOWANIA
    )


    )

Wybierz ile par przeskanowaÄ‡:
    )


    )

ğŸ’¡ WiÄ™ksza liczba = wiÄ™cej sygnaÅ‚Ã³w
    )

âš ï¸ WiÄ™ksza liczba = dÅ‚uÅ¼sze skanowanie"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ”Ÿ TOP 10 par", callback_data='ai_size_top10')],
    )

        [InlineKeyboardButton("5ï¸âƒ£0ï¸âƒ£ TOP 50 par", callback_data='ai_size_top50')],
    )

        [InlineKeyboardButton("ğŸ’¯ TOP 100 par", callback_data='ai_size_top100')],
    )

        [InlineKeyboardButton("2ï¸âƒ£0ï¸âƒ£0ï¸âƒ£ TOP 200 par", callback_data='ai_size_top200')],
    )

        [InlineKeyboardButton("3ï¸âƒ£0ï¸âƒ£0ï¸âƒ£ TOP 300 par", callback_data='ai_size_top300')],
    )

        [InlineKeyboardButton("ğŸŒ WSZYSTKIE pary", callback_data='ai_size_all')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def ai_scan_select_size(query, user_id, user, timeframe):
    )

    """Select scan size before scanning"""
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    
    )

    text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
    )


    )

â± Timeframe: {advanced_ai_signals.timeframes.get(timeframe, timeframe)}
    )


    )

ğŸ“Š WYBIERZ ZAKRES SKANOWANIA:
    )


    )

ğŸ” TOP 10/50 = NajwiÄ™ksze kryptowaluty (BTC, ETH, SOL...)
    )

ğŸ“Š 100+ = Wszystkie dostÄ™pne pary na gieÅ‚dzie
    )


    )

ğŸ’¡ WiÄ™cej par = wiÄ™cej sygnaÅ‚Ã³w
    )

âš ï¸ WiÄ™cej par = dÅ‚uÅ¼sze skanowanie"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton("ğŸ” TOP 10 crypto (~5s)", callback_data=f'ai_run_{timeframe}_top10')],
    )

        [InlineKeyboardButton("ğŸ” TOP 50 crypto (~20s)", callback_data=f'ai_run_{timeframe}_top50')],
    )

        [InlineKeyboardButton("ğŸ“Š TOP 100 par (~40s)", callback_data=f'ai_run_{timeframe}_top100')],
    )

        [InlineKeyboardButton("ğŸ“Š TOP 200 par (~80s)", callback_data=f'ai_run_{timeframe}_top200')],
    )

        [InlineKeyboardButton("ğŸ“Š TOP 500 par (~3min)", callback_data=f'ai_run_{timeframe}_top500')],
    )

        [InlineKeyboardButton("ğŸŒ WSZYSTKIE pary (~5min)", callback_data=f'ai_run_{timeframe}_all')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

async def ai_scan_execute(query, user_id, user, timeframe, scan_size="top10"):
    )

    """Execute AI scan with TILES"""
    )

    exchange = user.get('selected_exchange', 'mexc').lower()
    )

    
    )

    await query.edit_message_text(f"""ğŸ¤– SKANOWANIE AI...
    )


    )

â± Timeframe: {advanced_ai_signals.timeframes.get(timeframe, timeframe)}
    )

ğŸŒ GieÅ‚da: {EXCHANGES[exchange]['name']}
    )

ğŸ“Š Zakres: {scan_size.upper()}
    )


    )

â³ ProszÄ™ czekaÄ‡...""")
    )

    
    )

    try:
    )

        results = await advanced_ai_signals.scan_with_filters(exchange, timeframe, scan_size)
    )

        
    )

        if not results:
    )

            await query.edit_message_text("âŒ Brak sygnaÅ‚Ã³w speÅ‚niajÄ…cych kryteria", reply_markup=back_button('ai_signals'))
    )

            return
    )

        
    )

        # Tekst nagÅ‚Ã³wka
    )

        text = f"""ğŸ¤– SYGNAÅY AI - {EXCHANGES[exchange]['name']}
    )


    )

â± Timeframe: {advanced_ai_signals.timeframes.get(timeframe, timeframe)}
    )

ğŸ“Š Znaleziono: {len(results)} sygnaÅ‚Ã³w
    )


    )

ğŸ’¡ Kliknij parÄ™ aby zobaczyÄ‡ peÅ‚nÄ… analizÄ™ AI!
    )

"""
    )

        
    )

        # KAFELKI zamiast tekstu!
    )

        keyboard = []
    )

        
    )

        for r in results[:10]:
    )

            emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´"
    )

            clean_symbol = r['symbol'].replace('/USDT:USDT', '').replace(':USDT', '')
    )

            display_symbol = r["symbol"].replace(":USDT", "")
    )

            label = f"{emoji} {display_symbol} | {r['signal']} {int(r.get('score', r.get('confidence', 50)))}%~"
    )

            # Dodaj marker context: ai_sig_
    )

            keyboard.append([InlineKeyboardButton(label, callback_data=f'ai_sig_{clean_symbol}_{timeframe}')])
    )

        
    )

        # Przyciski akcji
    )

        keyboard.append([InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data=f'ai_run_{timeframe}_{scan_size}')])
    )

        keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='show_cached_scan')])
    )

        
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

        # Zapisz context dla przycisku powrÃ³t
    )

        user['signals_count'] = user.get('signals_count', 0) + len(results)
    )

        user['last_scan_size'] = scan_size
    )

        user['last_timeframe'] = timeframe
    )

        user['cached_scan_results'] = [
    )

            {
    )

                'symbol': r['symbol'],
    )

                'signal': r['signal'],
    )

                'score': int(r.get('score', r.get('confidence', 50)))
    )

            }
    )

            for r in results[:10]
    )

        ]
    )

        logger.info(f"Cached {len(user['cached_scan_results'])} results")
    )

        user['last_scan_size'] = scan_size
    )

        db.update_user(user_id, user)
    )

        
    )

    except Exception as e:
    )

        logger.error(f"AI scan error: {e}")
    )

        await query.edit_message_text(f"âŒ BÅ‚Ä…d: {e}", reply_markup=back_button('ai_signals'))
    )


    )

logger.info("âœ… Advanced AI Signals handlers added")
    )


    )

# ==========================================
    )

# CENTRALNY ANALYZER - DETAILED VIEW
    )

# ==========================================
    )

from central_ai_analyzer import central_analyzer
    )

from languages import t, get_user_language, TRANSLATIONS
    )


    )


    )


    )

async def show_cached_scan(query, user_id, user):
    )

    """Show cached scan results"""
    )

    # Pobierz Å›wieÅ¼y user z DB (z zapisanym cache)
    )

    user = db.get_user(user_id)
    )

    
    )

    
    )

    cached = user.get('cached_scan_results')
    )

    
    )

    if not cached or len(cached) == 0:
    )

        logger.info(f"No cache, starting new scan")
    )

        timeframe = user.get('last_timeframe', '30m')
    )

        scan_size = user.get('last_scan_size', 'top50')
    )

        await ai_scan_execute(query, user_id, user, timeframe, scan_size)
    )

        return
    )

    
    )

    logger.info(f"Showing {len(cached)} cached results")
    )

    
    )

    timeframe = user.get('last_timeframe', '30m')
    )

    scan_size = user.get('last_scan_size', 'top50')
    )

    exchange = user.get('selected_exchange', 'mexc')
    )

    
    )

    size_labels = {
    )

        'top10': 'TOP10', 'top20': 'TOP20', 'top30': 'TOP30',
    )

        'top50': 'TOP50', 'top100': 'TOP100', 'all': 'WSZYSTKIE'
    )

    }
    )

    
    )

    tf_labels = {'15m': '15 minut', '30m': '30 minut', '1h': '1 godzina', '4h': '4 godziny'}
    )

    
    )

    text = f"""ğŸ¯ SYGNAÅY AI - {exchange.upper()}
    )


    )

â± Timeframe: {tf_labels.get(timeframe, timeframe)}
    )

ğŸ“Š Zakres: {size_labels.get(scan_size, scan_size.upper())}
    )

ğŸ” Znaleziono: {len(cached)} sygnaÅ‚Ã³w
    )


    )

{"="*30}
    )

"""
    )

    
    )

    for i, r in enumerate(cached[:10], 1):
    )

        emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´" if r['signal'] == 'SHORT' else "âšª"
    )

        display_symbol = r['symbol'].replace(":USDT", "")
    )

        
    )

        text += f"""{i}. {emoji} {display_symbol}
    )

   {r['signal']} | PewnoÅ›Ä‡: {r['score']}%~
    )


    )

"""
    )

    
    )

    text += f"""{"="*30}
    )


    )

ğŸ’¡ Kliknij parÄ™ aby zobaczyÄ‡ szczegÃ³Å‚y
    )

âš ï¸ %~ = wstÄ™pna ocena"""
    )

    
    )

    # Kafelki
    )

    keyboard = []
    )

    for r in cached[:10]:
    )

        clean_symbol = r['symbol'].replace('/USDT:USDT', '').replace(':USDT', '')
    )

        emoji = "ğŸŸ¢" if r['signal'] == 'LONG' else "ğŸ”´"
    )

        label = f"{emoji} {clean_symbol} | {r['signal']} {r['score']}%~"
    )

        
    )

        keyboard.append([InlineKeyboardButton(
    )

            label, 
    )

            callback_data=f"ai_sig_{clean_symbol}_{timeframe}"
    )

        )])
    )

    
    )

    keyboard.append([InlineKeyboardButton('ğŸ”„ Skanuj ponownie', callback_data=f'ai_scan_tf_{timeframe}')])
    )

    keyboard.append([InlineKeyboardButton('âš™ï¸ ZmieÅ„ ustawienia', callback_data='ai_scan_menu')])
    )

    keyboard.append([InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')])
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def show_pair_analysis(query, user_id, user, symbol, exchange, timeframe, context='general'):
    )

    """
    )

    GÅÃ“WNA FUNKCJA - PokaÅ¼ peÅ‚nÄ… analizÄ™ pary
    )

    WywoÅ‚ana z KAÅ»DEGO miejsca w bocie (search, scan, ai_signal)
    )

    """
    )

    
    )

    # Show loading
    )

    await query.edit_message_text(f"""ğŸ¤– ANALIZA AI - {symbol}
    )


    )

â³ AnalizujÄ™...
    )


    )

ğŸ“Š Pobieranie danych z gieÅ‚dy
    )

ğŸ” Analiza techniczna (RSI, EMA, MACD...)
    )

ğŸ“ˆ Wykrywanie struktur rynku
    )

ğŸ’ DeepSeek AI reasoning
    )

ğŸ“° Sprawdzanie newsÃ³w
    )


    )

ProszÄ™ czekaÄ‡ ~10 sekund...""")
    )

    
    )

    try:
    )

        # CALL CENTRAL ANALYZER
    )

        analysis = await central_analyzer.analyze_pair_full(
    )

            exchange=exchange,
    )

            symbol=symbol,
    )

            timeframe=timeframe,
    )

            context=context
    )

        )
    )

        
    )

        if not analysis:
    )

            await query.edit_message_text(
    )

                f"âŒ Nie udaÅ‚o siÄ™ przeanalizowaÄ‡ {symbol}",
    )

                reply_markup=back_button('back_main')
    )

            )
    )

            return
    )

        
    )

        # Build beautiful report with user's language
    )

        lang = get_user_language(user)
    )

        text = format_analysis_report(analysis, lang)
    )

        
    )

        # Buttons - context-aware back button
    )

        clean_symbol = symbol.replace('/USDT', '').replace('/', '')
    )

        
    )

        # Determine back button based on context
    )

        if context == 'ai_signal':
    )

            back_data = f'ai_run_{timeframe}_{user.get("last_scan_size", "top10")}'
    )

            back_label = 'â¬…ï¸ WrÃ³Ä‡ do sygnaÅ‚Ã³w'
    )

        elif context == 'scan_extreme':
    )

            back_data = f'scan_{user.get("last_scan_type", "gainers")}'
    )

            back_label = 'â¬…ï¸ WrÃ³Ä‡ do skanera'
    )

        elif context == 'search':
    )

            back_data = 'back_main'
    )

            back_label = 'â¬…ï¸ Menu gÅ‚Ã³wne'
    )

        else:
    )

            back_data = 'back_main'
    )

            back_label = 'â¬…ï¸ Menu gÅ‚Ã³wne'
    )

        
    )

        keyboard = [
    )

            [InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼ analizÄ™', callback_data=f'refresh_analysis_{symbol}_{timeframe}')],
    )

            [InlineKeyboardButton(back_label, callback_data=back_data)]
    )

        ]
    )

        
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

        # Increment counter
    )

        user['signals_count'] = user.get('signals_count', 0) + 1
    )

        db.update_user(user_id, user)
    )

        
    )

    except Exception as e:
    )

        logger.error(f"Analysis display error: {e}")
    )

        await query.edit_message_text(
    )

            f"âŒ BÅ‚Ä…d analizy: {e}",
    )

            reply_markup=back_button('back_main')
    )

        )
    )


    )

def generate_ai_summary(signal, technical, sentiment, lang='pl'):
    )

    """Generate simple AI summary in user's language"""
    )

    
    )

    direction = signal['direction']
    )

    confidence = signal['confidence']
    )

    rsi = technical['rsi']['14']
    )

    price = technical['price']
    )

    
    )

    # Templates for each language
    )

    templates = {
    )

        'pl': {
    )

            'LONG': f"ğŸ“Š Analiza wskazuje na potencjalnÄ… okazjÄ™ do KUPNA z pewnoÅ›ciÄ… {confidence}%. RSI na poziomie {rsi:.0f} {'sugeruje wyprzedanie - dobry moment na wejÅ›cie' if rsi < 35 else 'jest w akceptowalnym zakresie'}. Cena wynosi ${price:.6f}. Rekomendujemy rozwaÅ¼enie pozycji dÅ‚ugiej z zaproponowanymi poziomami TP/SL.",
    )

            'SHORT': f"ğŸ“Š Analiza wskazuje na potencjalnÄ… okazjÄ™ do SPRZEDAÅ»Y z pewnoÅ›ciÄ… {confidence}%. RSI na poziomie {rsi:.0f} {'sugeruje wykupienie - moÅ¼liwa korekta' if rsi > 65 else 'jest w akceptowalnym zakresie'}. Cena wynosi ${price:.6f}. Rekomendujemy rozwaÅ¼enie pozycji krÃ³tkiej z zaproponowanymi poziomami TP/SL.",
    )

            'NEUTRAL': f"ğŸ“Š Analiza nie wskazuje wyraÅºnego kierunku (pewnoÅ›Ä‡ {confidence}%). RSI na poziomie {rsi:.0f}. Cena wynosi ${price:.6f}. Rekomendujemy poczekaÄ‡ na lepszy setup lub potwierdzenie sygnaÅ‚u."
    )

        },
    )

        'en': {
    )

            'LONG': f"ğŸ“Š Analysis indicates potential BUY opportunity with {confidence}% confidence. RSI at {rsi:.0f} {'suggests oversold conditions - good entry point' if rsi < 35 else 'is within acceptable range'}. Price is ${price:.6f}. Consider long position with suggested TP/SL levels.",
    )

            'SHORT': f"ğŸ“Š Analysis indicates potential SELL opportunity with {confidence}% confidence. RSI at {rsi:.0f} {'suggests overbought conditions - correction possible' if rsi > 65 else 'is within acceptable range'}. Price is ${price:.6f}. Consider short position with suggested TP/SL levels.",
    )

            'NEUTRAL': f"ğŸ“Š Analysis shows no clear direction (confidence {confidence}%). RSI at {rsi:.0f}. Price is ${price:.6f}. Recommend waiting for better setup or signal confirmation."
    )

        }
    )

    }
    )

    
    )

    # Get template for language (fallback to English)
    )

    lang_templates = templates.get(lang, templates['en'])
    )

    summary = lang_templates.get(direction, lang_templates['NEUTRAL'])
    )

    
    )

    return summary
    )


    )

def format_analysis_report(analysis, lang='pl'):
    )

    """Format analysis into beautiful Telegram message"""
    )

    
    )

    symbol = analysis['symbol']
    )

    signal = analysis['signal']
    )

    technical = analysis['technical']
    )

    sentiment = analysis['sentiment']
    )

    structure = analysis['structure']
    )

    volume = analysis['volume']
    )

    
    )

    # Header
    )

    direction_emoji = "ğŸŸ¢" if signal['direction'] == 'LONG' else "ğŸ”´" if signal['direction'] == 'SHORT' else "âšª"
    )

    
    )

    # Translations
    )

    direction_text = {
    )

        'LONG': {'pl': 'KUPUJ', 'en': 'BUY', 'es': 'COMPRAR', 'de': 'KAUFEN', 'fr': 'ACHETER', 'it': 'ACQUISTA', 'pt': 'COMPRAR', 'ru': 'ĞŸĞĞšĞ£ĞŸĞĞ¢Ğ¬', 'tr': 'AL', 'zh': 'ä¹°å…¥'},
    )

        'SHORT': {'pl': 'SPRZEDAJ', 'en': 'SELL', 'es': 'VENDER', 'de': 'VERKAUFEN', 'fr': 'VENDRE', 'it': 'VENDI', 'pt': 'VENDER', 'ru': 'ĞŸĞ ĞĞ”ĞĞ¢Ğ¬', 'tr': 'SAT', 'zh': 'å–å‡º'},
    )

        'NEUTRAL': {'pl': 'CZEKAJ', 'en': 'WAIT', 'es': 'ESPERAR', 'de': 'WARTEN', 'fr': 'ATTENDRE', 'it': 'ASPETTA', 'pt': 'AGUARDAR', 'ru': 'Ğ–Ğ”ĞĞ¢Ğ¬', 'tr': 'BEKLE', 'zh': 'ç­‰å¾…'}
    )

    }
    )

    
    )

    direction_label = direction_text.get(signal['direction'], {}).get(lang, signal['direction'])
    )

    
    )

    # Calculate TP percentages properly
    )

    entry = signal['entry']
    )

    tp1_pct = ((signal['tp1'] - entry) / entry * 100) if entry > 0 else 0
    )

    tp2_pct = ((signal['tp2'] - entry) / entry * 100) if entry > 0 else 0
    )

    tp3_pct = ((signal['tp3'] - entry) / entry * 100) if entry > 0 else 0
    )

    
    )

    # Specjalne formatowanie dla NEUTRAL
    )

    if signal['direction'] == 'NEUTRAL':
    )

        reco_text = f"""ğŸ¯ REKOMENDACJE:
    )

âš ï¸ Brak wyraÅºnego kierunku - podajemy range:
    )

â€¢ Cena: ${entry:.6f}
    )

â€¢ Upside target: ${signal['tp1']:.6f} ({tp1_pct:+.2f}%)
    )

â€¢ Downside target: ${signal['tp2']:.6f} ({tp2_pct:+.2f}%)
    )


    )

ğŸ’¡ Rekomendacja: Poczekaj na wyraÅºniejszy sygnaÅ‚!"""
    )

    else:
    )

        reco_text = f"""ğŸ¯ REKOMENDACJE:
    )

â€¢ Entry: ${entry:.6f}
    )

â€¢ TP1: ${signal['tp1']:.6f} ({tp1_pct:+.2f}%)
    )

â€¢ TP2: ${signal['tp2']:.6f} ({tp2_pct:+.2f}%)
    )

â€¢ TP3: ${signal['tp3']:.6f} ({tp3_pct:+.2f}%)
    )

â€¢ Stop Loss: ${signal['sl']:.6f}
    )

â€¢ R/R Ratio: {signal['rr_ratio']:.2f}"""
    )

    
    )

    text = f"""{direction_emoji} {t('signal', lang)} AI - {symbol}
    )


    )

{'='*30}
    )

ğŸ¯ SYGNAÅ: {direction_label} ({signal['confidence']}%)
    )

{'='*30}
    )


    )

ğŸ’° CENA: ${technical['price']:.6f}
    )

ğŸ“Š Zmiana 24h: {technical['change_24h']:+.2f}%
    )

â± Timeframe: {analysis['timeframe']} | ğŸŒ {analysis['exchange'].upper()} | ğŸ• {datetime.now().strftime('%H:%M:%S')}
    )


    )

{reco_text}
    )


    )

"""
    )

    
    )

    # Sentiment (multilang)
    )

    sentiment_labels = {
    )

        'pl': {'label': 'ğŸ“ˆ SENTYMENT RYNKU:'},
    )

        'en': {'label': 'ğŸ“ˆ MARKET SENTIMENT:'},
    )

        'es': {'label': 'ğŸ“ˆ SENTIMIENTO:'},
    )

        'de': {'label': 'ğŸ“ˆ MARKTSTIMMUNG:'},
    )

        'fr': {'label': 'ğŸ“ˆ SENTIMENT:'},
    )

        'it': {'label': 'ğŸ“ˆ SENTIMENTO:'},
    )

        'pt': {'label': 'ğŸ“ˆ SENTIMENTO:'},
    )

        'ru': {'label': 'ğŸ“ˆ ĞĞĞ¡Ğ¢Ğ ĞĞ•ĞĞ˜Ğ•:'},
    )

        'tr': {'label': 'ğŸ“ˆ DUYGU:'},
    )

        'zh': {'label': 'ğŸ“ˆ å¸‚åœºæƒ…ç»ª:'}
    )

    }
    )

    
    )

    text += f"""{sentiment_labels.get(lang, sentiment_labels['pl'])['label']}
    )

{sentiment['label']} ({sentiment['score']:+d}/100)
    )


    )

"""
    )

    
    )

    # Technical indicators (multilang)
    )

    rsi = technical['rsi']['14']
    )

    
    )

    tech_labels = {
    )

        'pl': 'WSKAÅ¹NIKI TECHNICZNE',
    )

        'en': 'TECHNICAL INDICATORS',
    )

        'es': 'INDICADORES TÃ‰CNICOS',
    )

        'de': 'TECHNISCHE INDIKATOREN',
    )

        'fr': 'INDICATEURS TECHNIQUES',
    )

        'it': 'INDICATORI TECNICI',
    )

        'pt': 'INDICADORES TÃ‰CNICOS',
    )

        'ru': 'Ğ¢Ğ•Ğ¥ĞĞ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• Ğ˜ĞĞ”Ğ˜ĞšĞĞ¢ĞĞ Ğ«',
    )

        'tr': 'TEKNÄ°K GÃ–STERGELER',
    )

        'zh': 'æŠ€æœ¯æŒ‡æ ‡'
    )

    }
    )

    
    )

    rsi_label = "ğŸ”¥ Oversold" if rsi < 20 else "ğŸ’ Overbought" if rsi > 80 else ""
    )

    
    )

    text += f"""ğŸ”§ {tech_labels.get(lang, 'WSKAÅ¹NIKI TECHNICZNE')}:
    )

â€¢ RSI(14): {rsi:.1f} {rsi_label}
    )

â€¢ EMA(9): ${technical['ema']['9']:.2f}
    )

â€¢ EMA(21): ${technical['ema']['21']:.2f}
    )

â€¢ MACD: {technical['macd']['histogram']:.2f}
    )


    )

"""
    )

    
    )

    # Volume (multilang)
    )

    vol_labels = {
    )

        'pl': {'title': 'WOLUMEN', 'ratio': 'Ratio', 'avg': 'Å›redniej', 'buy': 'Buying pressure', 'sell': 'Selling pressure'},
    )

        'en': {'title': 'VOLUME', 'ratio': 'Ratio', 'avg': 'average', 'buy': 'Buying pressure', 'sell': 'Selling pressure'},
    )

        'es': {'title': 'VOLUMEN', 'ratio': 'Ratio', 'avg': 'promedio', 'buy': 'PresiÃ³n compradora', 'sell': 'PresiÃ³n vendedora'},
    )

        'de': {'title': 'VOLUMEN', 'ratio': 'VerhÃ¤ltnis', 'avg': 'Durchschnitt', 'buy': 'Kaufdruck', 'sell': 'Verkaufsdruck'},
    )

        'ru': {'title': 'ĞĞ‘ĞªĞ•Ğœ', 'ratio': 'Ğ¡Ğ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ', 'avg': 'ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾', 'buy': 'Ğ”Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿Ğ¾Ğº', 'sell': 'Ğ”Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶'},
    )

    }
    )

    v = vol_labels.get(lang, vol_labels['pl'])
    )

    
    )

    text += f"""ğŸ“Š {v['title']}:
    )

â€¢ {v['ratio']}: {volume['ratio']:.2f}x {v['avg']}
    )

â€¢ {v['buy']}: {volume['buy_pressure']:.0f}%
    )

â€¢ {v['sell']}: {volume['sell_pressure']:.0f}%
    )


    )

"""
    )

    
    )

    # Support/Resistance (multilang)
    )

    if structure.get('support'):
    )

        sr_labels = {
    )

            'pl': {'title': 'WSPARCIE/OPÃ“R', 'support': 'Wsparcie', 'resistance': 'OpÃ³r'},
    )

            'en': {'title': 'SUPPORT/RESISTANCE', 'support': 'Support', 'resistance': 'Resistance'},
    )

            'es': {'title': 'SOPORTE/RESISTENCIA', 'support': 'Soporte', 'resistance': 'Resistencia'},
    )

            'de': {'title': 'UNTERSTÃœTZUNG/WIDERSTAND', 'support': 'UnterstÃ¼tzung', 'resistance': 'Widerstand'},
    )

            'ru': {'title': 'ĞŸĞĞ”Ğ”Ğ•Ğ Ğ–ĞšĞ/Ğ¡ĞĞŸĞ ĞĞ¢Ğ˜Ğ’Ğ›Ğ•ĞĞ˜Ğ•', 'support': 'ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°', 'resistance': 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ'},
    )

        }
    )

        sr = sr_labels.get(lang, sr_labels['pl'])
    )

        
    )

        text += f"""ğŸ“ {sr['title']}:
    )

â€¢ {sr['support']}: ${structure['support'][0]:.4f}
    )

â€¢ {sr['resistance']}: ${structure['resistance'][0]:.4f}
    )


    )

"""
    )

    
    )

    # AI Reasoning (multilang)
    )

    reasoning_labels = {
    )

        'pl': 'ANALIZA AI',
    )

        'en': 'AI REASONING',
    )

        'es': 'ANÃLISIS IA',
    )

        'de': 'KI-ANALYSE',
    )

        'fr': 'ANALYSE IA',
    )

        'it': 'ANALISI IA',
    )

        'pt': 'ANÃLISE IA',
    )

        'ru': 'Ğ˜Ğ˜ ĞĞĞĞ›Ğ˜Ğ—',
    )

        'tr': 'YAPAY ZEKA ANALÄ°ZÄ°',
    )

        'zh': 'AIåˆ†æ'
    )

    }
    )

    
    )

    # Translate reasons
    )

    reason_translations = {
    )

        'oversold_signal': {'pl': 'SygnaÅ‚ wyprzedania', 'en': 'Oversold signal'},
    )

        'Low RSI': {'pl': 'Niski RSI', 'en': 'Low RSI'},
    )

        'Strong downtrend': {'pl': 'Silny trend spadkowy', 'en': 'Strong downtrend'},
    )

        'Selling pressure': {'pl': 'Presja sprzedaÅ¼y', 'en': 'Selling pressure'},
    )

        'Strong uptrend': {'pl': 'Silny trend wzrostowy', 'en': 'Strong uptrend'},
    )

        'Buying pressure': {'pl': 'Presja kupna', 'en': 'Buying pressure'},
    )

        'Volume spike': {'pl': 'Skok wolumenu', 'en': 'Volume spike'},
    )

        'High volatility': {'pl': 'Wysoka zmiennoÅ›Ä‡', 'en': 'High volatility'},
    )

    }
    )

    
    )

    text += f"""ğŸ¤– {reasoning_labels.get(lang, 'ANALIZA AI')}:
    )

"""
    )

    for reason in signal['reasons'][:5]:
    )

        # Try to translate
    )

        translated = reason
    )

        for key, trans in reason_translations.items():
    )

            if key in reason:
    )

                translated = trans.get(lang, reason)
    )

                break
    )

        text += f"â€¢ {translated}\n"
    )

    
    )

    # AI PODSUMOWANIE
    )

    ai_summary = generate_ai_summary(signal, technical, sentiment, lang)
    )

    
    )

    text += f"""
    )

{'='*30}
    )

ğŸ¤– PODSUMOWANIE AI
    )

{'='*30}
    )


    )

{ai_summary}
    )


    )

{'='*30}
    )

{t('disclaimer', lang)}
    )

{'='*30}
    )

"""
    )

    
    )

    return text
    )


    )

logger.info("âœ… Central analyzer handlers added")
    )


    )

# ==========================================
    )

# LANGUAGE SETTINGS
    )

# ==========================================
    )

async def language_menu(query, user_id, user):
    )

    """Language selection menu"""
    )

    from languages import LANGUAGES
    )

    
    )

    text = """ğŸŒ WYBIERZ JÄ˜ZYK / SELECT LANGUAGE
    )


    )

Wybierz swÃ³j jÄ™zyk:
    )

Select your language:"""
    )

    
    )

    keyboard = []
    )

    for lang_code, lang_data in LANGUAGES.items():
    )

        keyboard.append([InlineKeyboardButton(lang_data['name'], callback_data=f'set_lang_{lang_code}')])
    )

    
    )

    keyboard.append([InlineKeyboardButton('â¬…ï¸ PowrÃ³t / Back', callback_data='settings')])
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

logger.info("âœ… Language menu added")
    )


    )

# ==========================================
    )

# EXPLANATIONS MENU
    )


    )


    )

# ==========================================
    )

# ALERTS SYSTEM
    )

# ==========================================
    )


    )

async def alerts_menu(query, user_id, user):
    )

    """Main alerts menu"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    # Status emoji
    )

    def status(enabled):
    )

        return 'âœ…' if enabled else 'âŒ'
    )

    
    )

    text = f"""ğŸ”” SYSTEM ALERTÃ“W
    )


    )

ğŸ“Š Status alertÃ³w:
    )

{status(settings['oversold_enabled'])} Oversold (RSI < 20)
    )

{status(settings['overbought_enabled'])} Overbought (RSI > 80)
    )

{status(settings['big_gains_enabled'])} DuÅ¼e Wzrosty (+{settings['gain_threshold']}%)
    )

{status(settings['big_losses_enabled'])} DuÅ¼e Spadki (-{settings['loss_threshold']}%)
    )

{status(settings['ai_signals_enabled'])} SygnaÅ‚y AI (>{settings['min_confidence']}%)
    )

{status(settings['volume_spike_enabled'])} Volume Spike (>{settings['volume_multiplier']}x)
    )

{status(settings['macd_cross_enabled'])} MACD Cross
    )

{status(settings['ema_cross_enabled'])} EMA Cross
    )

{status(settings.get('sudden_change_enabled', 0))} NagÅ‚e Zmiany ({settings.get('sudden_timeframe', '15m')}, Â±{settings.get('sudden_threshold', 5)}%)
    )


    )

ğŸ”” Powiadomienia: {'âœ… WÅ‚Ä…czone' if settings.get('notifications_enabled', 1) else 'âŒ WyÅ‚Ä…czone'}
    )


    )

âš™ï¸ Ustawienia skanera:
    )

ğŸ“Š Zakres: TOP {settings['scan_range']}
    )

â° CzÄ™stotliwoÅ›Ä‡: {settings['scan_frequency']}
    )

ğŸ“ˆ Timeframe: {settings.get('alert_timeframe', '1h')}
    )


    )

Bot automatycznie skanuje rynek i wysyÅ‚a powiadomienia o okazjach!"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('âš™ï¸ Ustawienia AlertÃ³w', callback_data='alerts_settings')],
    )

        [InlineKeyboardButton('ğŸ“œ Historia (ostatnie 50)', callback_data='alerts_history')],
    )

        [InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def alerts_settings_menu(query, user_id, user):
    )

    """Alert settings menu"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    def btn(name, enabled):
    )

        emoji = 'âœ…' if enabled else 'âŒ'
    )

        return InlineKeyboardButton(f'{emoji} {name}', callback_data=f'toggle_alert_{name.lower().replace(" ", "_")}')
    )

    
    )

    text = """âš™ï¸ USTAWIENIA ALERTÃ“W
    )


    )

Kliknij aby wÅ‚Ä…czyÄ‡/wyÅ‚Ä…czyÄ‡:"""
    )

    
    )

    keyboard = [
    )

        [btn('Oversold', settings['oversold_enabled'])],
    )

        [btn('Overbought', settings['overbought_enabled'])],
    )

        [btn('DuÅ¼e Wzrosty', settings['big_gains_enabled'])],
    )

        [btn('DuÅ¼e Spadki', settings['big_losses_enabled'])],
    )

        [btn('SygnaÅ‚y AI', settings['ai_signals_enabled'])],
    )

        [btn('Volume Spike', settings['volume_spike_enabled'])],
    )

        [btn('MACD Cross', settings['macd_cross_enabled'])],
    )

        [btn('EMA Cross', settings['ema_cross_enabled'])],
    )

        [InlineKeyboardButton('â”â”â”â”â”â”â”â”â”â”', callback_data='none')],
    )

        [InlineKeyboardButton('ğŸ“Š Zakres skanowania', callback_data='set_scan_range')],
    )

        [InlineKeyboardButton('â° CzÄ™stotliwoÅ›Ä‡', callback_data='set_scan_frequency')],
    )

        [InlineKeyboardButton('ğŸ“ˆ Timeframe alertÃ³w', callback_data='set_alert_timeframe')],
    )

        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - TF', callback_data='set_sudden_timeframe')],
    )

        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - %', callback_data='set_sudden_threshold')],
    )

        [InlineKeyboardButton('ğŸ”” Powiadomienia', callback_data='toggle_alert_notifications_enabled')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def toggle_alert(query, user_id, user, alert_type):
    )

    """Toggle alert on/off"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    # Map button name to db field
    )

    field_map = {
    )

        'oversold': 'oversold_enabled',
    )

        'overbought': 'overbought_enabled',
    )

        'duÅ¼e_wzrosty': 'big_gains_enabled',
    )

        'duÅ¼e_spadki': 'big_losses_enabled',
    )

        'sygnaÅ‚y_ai': 'ai_signals_enabled',
    )

        'volume_spike': 'volume_spike_enabled',
    )

        'macd_cross': 'macd_cross_enabled',
    )

        'ema_cross': 'ema_cross_enabled'
    )

    }
    )

    
    )

    field = field_map.get(alert_type)
    )

    if field:
    )

        new_value = 0 if settings[field] else 1
    )

        db.update_alert_settings(user_id, {field: new_value})
    )

        await query.answer(f"{'âœ… WÅ‚Ä…czono' if new_value else 'âŒ WyÅ‚Ä…czono'} alert")
    )

    
    )

    await alerts_settings_menu(query, user_id, user)
    )


    )


    )

async def set_scan_range(query, user_id, user, range_val=None):
    )

    """Set scan range menu"""
    )

    if range_val:
    )

        db.update_alert_settings(user_id, {'scan_range': range_val})
    )

        await query.answer(f'âœ… Ustawiono zakres: TOP {range_val}')
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    text = """ğŸ“Š ZAKRES SKANOWANIA
    )


    )

Ile par ma byÄ‡ skanowanych?
    )


    )

â€¢ TOP 10 - najszybsze
    )

â€¢ TOP 50 - balans
    )

â€¢ TOP 100 - dokÅ‚adne
    )

â€¢ TOP 200 - bardzo dokÅ‚adne
    )

â€¢ ALL - wszystkie pary (wolne)"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('TOP 10', callback_data='set_scan_range_10'), InlineKeyboardButton('TOP 50', callback_data='set_scan_range_50')],
    )

        [InlineKeyboardButton('TOP 100', callback_data='set_scan_range_100'), InlineKeyboardButton('TOP 200', callback_data='set_scan_range_200')],
    )

        [InlineKeyboardButton('ALL (~700)', callback_data='set_scan_range_9999')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_scan_frequency(query, user_id, user, freq=None):
    )

    """Set scan frequency"""
    )

    if freq:
    )

        db.update_alert_settings(user_id, {'scan_frequency': freq})
    )

        await query.answer(f'âœ… CzÄ™stotliwoÅ›Ä‡: {freq}')
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    text = """â° CZÄ˜STOTLIWOÅšÄ† SKANOWANIA
    )


    )

Jak czÄ™sto bot ma sprawdzaÄ‡ rynek?
    )


    )

â€¢ 5m - bardzo czÄ™sto (wiÄ™cej alertÃ³w)
    )

â€¢ 15m - balans â­
    )

â€¢ 30m - rzadziej
    )

â€¢ 1h - oszczÄ™dne"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('5 minut', callback_data='set_scan_freq_5m'), InlineKeyboardButton('15 minut', callback_data='set_scan_freq_15m')],
    )

        [InlineKeyboardButton('30 minut', callback_data='set_scan_freq_30m'), InlineKeyboardButton('1 godzina', callback_data='set_scan_freq_1h')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

# ==========================================
    )

# ALERTS SYSTEM
    )

# ==========================================
    )


    )

async def alerts_menu(query, user_id, user):
    )

    """Main alerts menu"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    # Status emoji
    )

    def status(enabled):
    )

        return 'âœ…' if enabled else 'âŒ'
    )

    
    )

    text = f"""ğŸ”” SYSTEM ALERTÃ“W
    )


    )

ğŸ“Š Status alertÃ³w:
    )

{status(settings['oversold_enabled'])} Oversold (RSI < 20)
    )

{status(settings['overbought_enabled'])} Overbought (RSI > 80)
    )

{status(settings['big_gains_enabled'])} DuÅ¼e Wzrosty (+{settings['gain_threshold']}%)
    )

{status(settings['big_losses_enabled'])} DuÅ¼e Spadki (-{settings['loss_threshold']}%)
    )

{status(settings['ai_signals_enabled'])} SygnaÅ‚y AI (>{settings['min_confidence']}%)
    )

{status(settings['volume_spike_enabled'])} Volume Spike (>{settings['volume_multiplier']}x)
    )

{status(settings['macd_cross_enabled'])} MACD Cross
    )

{status(settings['ema_cross_enabled'])} EMA Cross
    )

{status(settings.get('sudden_change_enabled', 0))} NagÅ‚e Zmiany ({settings.get('sudden_timeframe', '15m')}, Â±{settings.get('sudden_threshold', 5)}%)
    )


    )

ğŸ”” Powiadomienia: {'âœ… WÅ‚Ä…czone' if settings.get('notifications_enabled', 1) else 'âŒ WyÅ‚Ä…czone'}
    )


    )

âš™ï¸ Ustawienia skanera:
    )

ğŸ“Š Zakres: TOP {settings['scan_range']}
    )

â° CzÄ™stotliwoÅ›Ä‡: {settings['scan_frequency']}
    )

ğŸ“ˆ Timeframe: {settings.get('alert_timeframe', '1h')}
    )


    )

Bot automatycznie skanuje rynek i wysyÅ‚a powiadomienia o okazjach!"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('âš™ï¸ Ustawienia AlertÃ³w', callback_data='alerts_settings')],
    )

        [InlineKeyboardButton('ğŸ“œ Historia (ostatnie 50)', callback_data='alerts_history')],
    )

        [InlineKeyboardButton('â¬…ï¸ Menu gÅ‚Ã³wne', callback_data='back_main')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def alerts_settings_menu(query, user_id, user):
    )

    """Alert settings menu"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    def btn(name, field):
    )

        emoji = 'âœ…' if settings[field] else 'âŒ'
    )

        return InlineKeyboardButton(f'{emoji} {name}', callback_data=f'toggle_alert_{field}')
    )

    
    )

    text = """âš™ï¸ USTAWIENIA ALERTÃ“W
    )


    )

Kliknij aby wÅ‚Ä…czyÄ‡/wyÅ‚Ä…czyÄ‡:"""
    )

    
    )

    keyboard = [
    )

        [btn('Oversold', 'oversold_enabled')],
    )

        [btn('Overbought', 'overbought_enabled')],
    )

        [btn('DuÅ¼e Wzrosty', 'big_gains_enabled')],
    )

        [btn('DuÅ¼e Spadki', 'big_losses_enabled')],
    )

        [btn('SygnaÅ‚y AI', 'ai_signals_enabled')],
    )

        [btn('Volume Spike', 'volume_spike_enabled')],
    )

        [btn('MACD Cross', 'macd_cross_enabled')],
    )

        [btn('EMA Cross', 'ema_cross_enabled')],
    )

        [btn('NagÅ‚e Zmiany', 'sudden_change_enabled')],
    )

        [InlineKeyboardButton('â”â”â”â”â”â”â”â”â”â”', callback_data='none')],
    )

        [InlineKeyboardButton('ğŸ“Š Zakres skanowania', callback_data='set_scan_range')],
    )

        [InlineKeyboardButton('â° CzÄ™stotliwoÅ›Ä‡', callback_data='set_scan_frequency')],
    )

        [InlineKeyboardButton('ğŸ“ˆ Timeframe alertÃ³w', callback_data='set_alert_timeframe')],
    )

        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - TF', callback_data='set_sudden_timeframe')],
    )

        [InlineKeyboardButton('âš¡ NagÅ‚e zmiany - %', callback_data='set_sudden_threshold')],
    )

        [InlineKeyboardButton('ğŸ”” Powiadomienia', callback_data='toggle_alert_notifications_enabled')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )


    )

async def toggle_alert(query, user_id, user, alert_type):
    )

    """Toggle alert on/off"""
    )

    settings = db.get_alert_settings(user_id)
    )

    
    )

    # alert_type to juÅ¼ nazwa pola z db (oversold_enabled, etc.)
    )

    if alert_type in settings:
    )

        new_value = 0 if settings[alert_type] else 1
    )

        db.update_alert_settings(user_id, {alert_type: new_value})
    )

        await query.answer(f"{'âœ… WÅ‚Ä…czono' if new_value else 'âŒ WyÅ‚Ä…czono'} alert")
    )

    
    )

    await alerts_settings_menu(query, user_id, user)
    )


    )


    )

async def set_scan_range(query, user_id, user, range_val=None):
    )

    """Set scan range menu"""
    )

    if range_val:
    )

        db.update_alert_settings(user_id, {'scan_range': range_val})
    )

        await query.answer(f'âœ… Ustawiono zakres: TOP {range_val}')
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    text = """ğŸ“Š ZAKRES SKANOWANIA
    )


    )

Ile par ma byÄ‡ skanowanych?
    )


    )

â€¢ TOP 10 - najszybsze
    )

â€¢ TOP 50 - balans
    )

â€¢ TOP 100 - dokÅ‚adne
    )

â€¢ TOP 200 - bardzo dokÅ‚adne
    )

â€¢ ALL - wszystkie pary (wolne)"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('TOP 10', callback_data='set_scan_range_10'), InlineKeyboardButton('TOP 50', callback_data='set_scan_range_50')],
    )

        [InlineKeyboardButton('TOP 100', callback_data='set_scan_range_100'), InlineKeyboardButton('TOP 200', callback_data='set_scan_range_200')],
    )

        [InlineKeyboardButton('ALL (~700)', callback_data='set_scan_range_9999')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_scan_frequency(query, user_id, user, freq=None):
    )

    """Set scan frequency"""
    )

    if freq:
    )

        db.update_alert_settings(user_id, {'scan_frequency': freq})
    )

        await query.answer(f'âœ… CzÄ™stotliwoÅ›Ä‡: {freq}')
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    text = """â° CZÄ˜STOTLIWOÅšÄ† SKANOWANIA
    )


    )

Jak czÄ™sto bot ma sprawdzaÄ‡ rynek?
    )


    )

â€¢ 5m - bardzo czÄ™sto (wiÄ™cej alertÃ³w)
    )

â€¢ 15m - balans â­
    )

â€¢ 30m - rzadziej
    )

â€¢ 1h - oszczÄ™dne"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('5 minut', callback_data='set_scan_freq_5m'), InlineKeyboardButton('15 minut', callback_data='set_scan_freq_15m')],
    )

        [InlineKeyboardButton('30 minut', callback_data='set_scan_freq_30m'), InlineKeyboardButton('1 godzina', callback_data='set_scan_freq_1h')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )


    )

async def alerts_history_menu(query, user_id, user):
    )

    """Show alert history as interactive cards"""
    )

    history = db.get_alert_history(user_id, limit=50)  # More alerts
    )

    
    )

    if not history:
    )

        text = "ğŸ“œ HISTORIA ALERTÃ“W\n\nBrak alertÃ³w w historii."
    )

        keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_menu')]]
    )

    else:
    )

        recent = history[:20]  # Show 20
    )

        text = "ğŸ“œ HISTORIA ALERTÃ“W\n\nKliknij aby zobaczyÄ‡ szczegÃ³Å‚y i analizÄ™:\n"
    )

        
    )

        keyboard = []
    )

        for i, alert in enumerate(recent):
    )

            alert_type = alert['alert_type'].upper()
    )

            symbol = alert['symbol'].split('/')[0]
    )

            message = alert['message']
    )

            
    )

            # Extract info from message
    )

            change = ""
    )

            if 'Zmiana 24h:' in message:
    )

                parts = message.split('Zmiana 24h:')
    )

                if len(parts) > 1:
    )

                    change = parts[1].split('\n')[0].strip()[:10]  # +15.3% or -10.2%
    )

            elif 'WZROST:' in message or 'SPADEK:' in message:
    )

                if '%' in message:
    )

                    # Extract % from sudden change
    )

                    parts = message.split('%')
    )

                    if len(parts) > 1:
    )

                        # Find number before %
    )

                        num_part = parts[0].split()[-1]
    )

                        change = num_part + '%'
    )

            
    )

            time = alert.get('triggered_at', alert.get('timestamp', ''))[:16].replace('T', ' ')[5:]  # MM-DD HH:MM
    )

            
    )

            emoji = {
    )

                'BIG_GAIN': 'ğŸš€', 'BIG_LOSS': 'ğŸ“‰',
    )

                'OVERSOLD': 'ğŸ”¥', 'OVERBOUGHT': 'ğŸ’',
    )

                'AI_SIGNAL': 'ğŸ¤–', 'VOLUME_SPIKE': 'ğŸ“Š',
    )

                'SUDDEN_CHANGE': 'âš¡'
    )

            }.get(alert_type, 'ğŸ””')
    )

            
    )

            # Better button text: emoji + symbol + change + time
    )

            button_text = f"{emoji} {symbol} {change} | {time}"
    )

            
    )

            keyboard.append([InlineKeyboardButton(
    )

                button_text,
    )

                callback_data=f'alert_detail_{i}'
    )

            )])
    )

        
    )

        keyboard.append([
    )

            InlineKeyboardButton('ğŸ”„ OdÅ›wieÅ¼', callback_data='alerts_history'),
    )

            InlineKeyboardButton('â¬…ï¸ Menu', callback_data='alerts_menu')
    )

        ])
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def analyze_from_alert(query, user_id, user, symbol, timeframe):
    )

    """Show FULL professional analysis using format_analysis_report"""
    )

    try:
    )

        await query.answer()
    )

        await query.edit_message_text('â³ AnalizujÄ™...')
    )

        
    )

        exchange = user.get('selected_exchange', 'mexc')
    )

        
    )

        # Use central_analyzer (same as AI Signals)
    )

        from central_ai_analyzer import central_analyzer
    )

        analysis = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe)
    )

        
    )

        if not analysis:
    )

            await query.edit_message_text(
    )

                f"âŒ Nie udaÅ‚o siÄ™ przeanalizowaÄ‡ {symbol}",
    )

                reply_markup=InlineKeyboardMarkup([[
    )

                    InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_history')
    )

                ]])
    )

            )
    )

            return
    )

        
    )

        # Format using THE SAME function as AI Signals!
    )

        from languages import get_user_language
    )

        lang = get_user_language(user)
    )

        text = format_analysis_report(analysis, lang)
    )

        
    )

        # Quick intervals at bottom
    )

        intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M']
    )

        keyboard = []
    )

        symbol_encoded = symbol.replace('/', '_').replace(':', '_')
    )

        
    )

        row = []
    )

        for i, tf in enumerate(intervals):
    )

            emoji_btn = 'âœ…' if tf == timeframe else 'â±'
    )

            row.append(InlineKeyboardButton(
    )

                f'{emoji_btn} {tf}',
    )

                callback_data=f'analyze_{symbol_encoded}_{tf}'
    )

            ))
    )

            if len(row) == 3:
    )

                keyboard.append(row)
    )

                row = []
    )

        if row:
    )

            keyboard.append(row)
    )

        
    )

        keyboard.append([
    )

            InlineKeyboardButton('ğŸ“œ Historia', callback_data='alerts_history'),
    )

            InlineKeyboardButton('ğŸ  Menu', callback_data='back_main')
    )

        ])
    )

        
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

    except Exception as e:
    )

        logger.error(f"Error in analyze_from_alert: {e}")
    )

        import traceback
    )

        traceback.print_exc()
    )

        
    )

        await query.edit_message_text(
    )

            f"âŒ BÅ‚Ä…d: {e}",
    )

            reply_markup=InlineKeyboardMarkup([[
    )

                InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_history')
    )

            ]])
    )

        )
    )


    )


    )

async def show_alert_detail(query, user_id, user, index):
    )

    """Show full alert details with DIRECT analysis"""
    )

    history = db.get_alert_history(user_id, limit=50)
    )

    
    )

    if index >= len(history):
    )

        await query.answer('âŒ Nie znaleziono')
    )

        return
    )

    
    )

    alert = history[index]
    )

    symbol = alert['symbol']
    )

    
    )

    # Get user settings
    )

    settings = db.get_alert_settings(user_id)
    )

    timeframe = settings.get('alert_timeframe', '1h')
    )

    exchange = user.get('selected_exchange', 'mexc')
    )

    
    )

    # Show loading
    )

    await query.edit_message_text('â³ ÅadujÄ™ analizÄ™...')
    )

    
    )

    try:
    )

        # Run analysis DIRECTLY
    )

        from central_ai_analyzer import central_analyzer
    )

        analysis = await central_analyzer.analyze_pair_full(symbol, exchange, timeframe)
    )

        
    )

        if not analysis:
    )

            raise Exception("Brak analizy")
    )

        
    )

        # Format result
    )

        signal = analysis.get('signal', 'NEUTRAL')
    )

        confidence = analysis.get('confidence', 0)
    )

        rsi = analysis.get('rsi', 0)
    )

        
    )

        signal_emoji = {'LONG': 'ğŸŸ¢', 'SHORT': 'ğŸ”´', 'NEUTRAL': 'âšª'}.get(signal, 'âšª')
    )

        
    )

        text = f"""ğŸ“Š ANALIZA: {symbol.split('/')[0]}
    )


    )

ğŸ”” Alert: {alert['alert_type'].upper()}
    )

â° {alert.get('triggered_at', '')[:16]}
    )


    )

{signal_emoji} SygnaÅ‚: {signal}
    )

ğŸ¯ PewnoÅ›Ä‡: {confidence}%
    )

ğŸ“ˆ RSI: {rsi:.1f}
    )

â± InterwaÅ‚: {timeframe}
    )


    )

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    )

âš¡ Szybka zmiana interwaÅ‚u:"""
    )

        
    )

        # Quick interval buttons
    )

        intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M']
    )

        keyboard = []
    )

        symbol_encoded = symbol.replace('/', '_').replace(':', '_')
    )

        
    )

        row = []
    )

        for i, tf in enumerate(intervals):
    )

            emoji = 'âœ…' if tf == timeframe else 'â±'
    )

            row.append(InlineKeyboardButton(f'{emoji} {tf}', callback_data=f'analyze_{symbol_encoded}_{tf}'))
    )

            
    )

            if len(row) == 3:
    )

                keyboard.append(row)
    )

                row = []
    )

        
    )

        if row:
    )

            keyboard.append(row)
    )

        
    )

        keyboard.append([
    )

            InlineKeyboardButton('ğŸ“œ Historia', callback_data='alerts_history'),
    )

            InlineKeyboardButton('ğŸ  Menu', callback_data='back_main')
    )

        ])
    )

        
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )

        
    )

    except Exception as e:
    )

        text = f"""âŒ BÅ‚Ä…d analizy
    )


    )

{alert['message']}
    )


    )

â° {alert.get('triggered_at', alert.get('timestamp', 'N/A'))}
    )


    )

BÅ‚Ä…d: {str(e)}"""
    )

        
    )

        keyboard = [[InlineKeyboardButton('ğŸ“œ PowrÃ³t', callback_data='alerts_history')]]
    )

        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_alert_timeframe(query, user_id, user, tf=None):
    )

    """Set alert timeframe"""
    )

    if tf:
    )

        db.update_alert_settings(user_id, {'alert_timeframe': tf})
    )

        await query.answer(f'âœ… Timeframe alertÃ³w: {tf}')
    )

        await alerts_settings_menu(query, user_id, user)
    )

        return
    )

    
    )

    text = """ğŸ“ˆ TIMEFRAME ALERTÃ“W
    )


    )

Na jakim interwale sprawdzaÄ‡ wskaÅºniki?
    )


    )

â€¢ 1m, 5m - bardzo krÃ³tki (scalping)
    )

â€¢ 15m, 30m - krÃ³tki (day trading)
    )

â€¢ 1h, 4h - Å›redni (swing) â­
    )

â€¢ 1d, 1w - dÅ‚ugi (pozycje)
    )

â€¢ 1M - bardzo dÅ‚ugi
    )


    )

WpÅ‚ywa na RSI, MACD, EMA, Volume.
    )

Zmiana 24h zawsze na 1d."""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('1m', callback_data='set_alert_tf_1m'), 
    )

         InlineKeyboardButton('5m', callback_data='set_alert_tf_5m'), 
    )

         InlineKeyboardButton('15m', callback_data='set_alert_tf_15m')],
    )

        [InlineKeyboardButton('30m', callback_data='set_alert_tf_30m'), 
    )

         InlineKeyboardButton('1h', callback_data='set_alert_tf_1h'), 
    )

         InlineKeyboardButton('4h', callback_data='set_alert_tf_4h')],
    )

        [InlineKeyboardButton('8h', callback_data='set_alert_tf_8h'), 
    )

         InlineKeyboardButton('1d', callback_data='set_alert_tf_1d'), 
    )

         InlineKeyboardButton('1w', callback_data='set_alert_tf_1w')],
    )

        [InlineKeyboardButton('1M', callback_data='set_alert_tf_1M')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_sudden_timeframe_menu(query, user_id, user):
    )

    """Menu timeframe dla nagÅ‚ych zmian"""
    )

    settings = db.get_alert_settings(user_id)
    )

    current = settings.get('sudden_timeframe', '15m')
    )

    
    )

    text = f"""âš¡ NAGÅE ZMIANY - TIMEFRAME
    )


    )

Obecny: {current}
    )


    )

Na jakim interwale sprawdzaÄ‡ nagÅ‚e zmiany ceny?
    )


    )

â€¢ 5m - bardzo czuÅ‚e (duÅ¼o alertÃ³w)
    )

â€¢ 15m - czuÅ‚e â­
    )

â€¢ 30m - umiarkowane
    )

â€¢ 1h - spokojne
    )

â€¢ 4h - bardzo spokojne
    )


    )

PrzykÅ‚ad: wzrost o 5% w ciÄ…gu 15 minut"""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('5m', callback_data='set_sudden_tf_5m'),
    )

         InlineKeyboardButton('15m', callback_data='set_sudden_tf_15m'),
    )

         InlineKeyboardButton('30m', callback_data='set_sudden_tf_30m')],
    )

        [InlineKeyboardButton('1h', callback_data='set_sudden_tf_1h'),
    )

         InlineKeyboardButton('4h', callback_data='set_sudden_tf_4h')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_sudden_timeframe(query, user_id, user, tf):
    )

    """Ustaw timeframe dla nagÅ‚ych zmian"""
    )

    db.update_alert_settings(user_id, {'sudden_timeframe': tf})
    )

    await query.answer(f'âœ… Timeframe nagÅ‚ych zmian: {tf}')
    )

    await alerts_settings_menu(query, user_id, user)
    )


    )


    )

async def set_sudden_threshold_menu(query, user_id, user):
    )

    """Menu progu % dla nagÅ‚ych zmian"""
    )

    settings = db.get_alert_settings(user_id)
    )

    current = settings.get('sudden_threshold', 5)
    )

    tf = settings.get('sudden_timeframe', '15m')
    )

    
    )

    text = f"""âš¡ NAGÅE ZMIANY - PRÃ“G %
    )


    )

Obecny: Â±{current}% w {tf}
    )


    )

Jaka zmiana% ma wywoÅ‚aÄ‡ alert?
    )


    )

â€¢ 3% - bardzo czuÅ‚e (duÅ¼o alertÃ³w)
    )

â€¢ 5% - czuÅ‚e â­
    )

â€¢ 7% - umiarkowane
    )

â€¢ 10% - spokojne
    )

â€¢ 15% - tylko duÅ¼e ruchy
    )


    )

Alert przyjdzie gdy cena zmieni siÄ™ o wybrany % w czasie {tf}."""
    )

    
    )

    keyboard = [
    )

        [InlineKeyboardButton('3%', callback_data='set_sudden_th_3'),
    )

         InlineKeyboardButton('5%', callback_data='set_sudden_th_5'),
    )

         InlineKeyboardButton('7%', callback_data='set_sudden_th_7')],
    )

        [InlineKeyboardButton('10%', callback_data='set_sudden_th_10'),
    )

         InlineKeyboardButton('15%', callback_data='set_sudden_th_15')],
    )

        [InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='alerts_settings')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )


    )

async def set_sudden_threshold(query, user_id, user, threshold):
    )

    """Ustaw prÃ³g % dla nagÅ‚ych zmian"""
    )

    db.update_alert_settings(user_id, {'sudden_threshold': threshold})
    )

    await query.answer(f'âœ… PrÃ³g nagÅ‚ych zmian: Â±{threshold}%')
    )

    await alerts_settings_menu(query, user_id, user)
    )


    )


    )


    )


    )

async def show_alert_detail(query, user_id, user, index):
    )

    """Show full alert details with analysis button"""
    )

    history = db.get_alert_history(user_id, limit=20)
    )

    
    )

    if index >= len(history):
    )

        await query.answer('âŒ Alert nie znaleziony')
    )

        return
    )

    
    )

    alert = history[index]
    )

    alert_type = alert['alert_type'].upper()
    )

    symbol = alert['symbol']
    )

    timestamp = alert.get('triggered_at', alert.get('timestamp', 'N/A'))
    )

    message = alert['message']
    )

    
    )

    # Get user's timeframe setting
    )

    settings = db.get_alert_settings(user_id)
    )

    timeframe = settings.get('alert_timeframe', '1h')
    )

    
    )

    text = f"""ğŸ“œ SZCZEGÃ“ÅY ALERTU
    )


    )

{message}
    )


    )

â° Czas: {timestamp}
    )

ğŸ”” Typ: {alert_type}
    )

"""
    )

    
    )

    # Buttons
    )

    symbol_encoded = symbol.replace('/', '_').replace(':', '_')
    )

    keyboard = [
    )

        [InlineKeyboardButton(
    )

            f'ğŸ“Š Analiza {symbol.split("/")[0]} ({timeframe})',
    )

            callback_data=f'analyze_{symbol_encoded}_{timeframe}'
    )

        )],
    )

        [InlineKeyboardButton('ğŸ“œ PowrÃ³t do historii', callback_data='alerts_history')]
    )

    ]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

# ==========================================
    )

async def explanations_menu(query, user_id, user):
    )

    """Explanations of trading terms"""
    )

    lang = get_user_language(user)
    )

    
    )

    text = f"""ğŸ“š WYJAÅšNIENIA TERMINÃ“W
    )


    )

{t('explain_rsi', lang)}
    )


    )

{t('explain_ema', lang)}
    )


    )

{t('explain_volume', lang)}
    )


    )

ğŸ’¡ **TP1/TP2/TP3** = Cele zysku (Take Profit) - poziomy gdzie zalecamy zamkniÄ™cie czÄ™Å›ci lub caÅ‚oÅ›ci pozycji z zyskiem
    )


    )

ğŸ’¡ **Stop Loss (SL)** = Poziom zamkniÄ™cia straty - punkt gdzie pozycja zostanie automatycznie zamkniÄ™ta aby ograniczyÄ‡ stratÄ™
    )


    )

ğŸ’¡ **R/R Ratio** = Stosunek zysku do ryzyka - ile moÅ¼esz zarobiÄ‡ w stosunku do tego ile ryzykujesz
    )


    )

ğŸ’¡ **Entry** = Punkt wejÅ›cia - zalecana cena otwarcia pozycji
    )


    )

ğŸ’¡ **Confidence %** = PewnoÅ›Ä‡ sygnaÅ‚u - im wyÅ¼szy % tym mocniejszy sygnaÅ‚ (70%+ = dobry, 80%+ = bardzo dobry)
    )


    )

ğŸ’¡ **LONG** = Pozycja dÅ‚uga - kupujesz oczekujÄ…c wzrostu ceny
    )


    )

ğŸ’¡ **SHORT** = Pozycja krÃ³tka - sprzedajesz oczekujÄ…c spadku ceny"""
    )

    
    )

    keyboard = [[InlineKeyboardButton('â¬…ï¸ PowrÃ³t', callback_data='back_main')]]
    )

    
    )

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    )


    )

logger.info("âœ… Explanations menu added")
    )


    )


# ==========================================
# SEARCH PAIR EXECUTION (TEXT INPUT)
# ==========================================
async def search_pair_execute(update, user_id, user, text):
    message = update.message
    exchange = user.get("selected_exchange", "mexc").lower()

    symbol = text.upper().replace("/USDT", "").strip()
    if not symbol.isalnum():
        await message.reply_text("âŒ NieprawidÅ‚owa nazwa pary. PrzykÅ‚ad: BTC")
        return

    pair = f"{symbol}/USDT"

    user["awaiting_search"] = False
    db.update_user(user_id, user)

    await show_pair_analysis(
        message,
        user_id,
        user,
        pair,
        exchange,
        user.get("interval", "15m"),
        CONTEXT_MANUAL
    )
